\chapter{Related work}\label{sec:rel}
This chapter reviews related work on the \emph{realisability problem} for
\emph{global types}, both within the same theoretical framework and in
closely related models.  
Our approach adopts a definition of global types that captures a set of
MSCs, following a line of research initiated in~\cite{di2023partial} and
extended in~\cite{di2025realisability}, which aims to establish a
general framework for communication semantics.  
We first discuss these foundational works to situate our own
contributions.  
We then examine recent advances by
Stutz~et~al.~\cite{stutz2024implementability}, who provide a
comprehensive automata-theoretic treatment of the realisability problem,
and trace this line of inquiry back to early results by
Alur~et~al.~\cite{alur2000inference} and
Lohrey~et~al.~\cite{lohrey2003realizability}.  
Finally, we consider related formalisms such as Multiparty Session Types
(MPST) and Choreography Automata~\cite{barbanera2020choreography},
highlighting conceptual connections and key differences with the
approach developed in this thesis.

\section{Hierarchy of communication model's semantics}\label{sec:hier}
We first defined some communication semantics of our interest in an informal way 
in Chapter~\ref{chap:intro}, and then we defined formally the $\synchmodel$
communication model in Definition~\ref{def:synchronous}.
Furthermore, \cite{di2023partial} shows some other interesting 
semantics. It also introduces a hierarchy of communication
semantics, illustrated in Figure~\ref{fig:coms}. The main objective of
this work was to establish a hierarchy that preserves \emph{monotonic}
properties: if a property holds for a given communication semantic, it
should also hold for all semantics contained within it. However, it was
shown that this monotonicity only applies to specific properties, such
as \emph{weak-$k$-synchronizability}. In contrast, it does not generally
extend to the realisability problem, that is why we focused
on specific semantics, i.e. peer-to-peer and synchronous communication. 
We define subsequently some other useful and
well known communication semantics. The reader can verify the membership
using~\cite{MSCTool}.

\bigskip

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[scale=0.6]
  % list of labels in order (from smallest to largest)
%   \def\labels{{rsc,nn,onen,mb,co,p2p,asy}}
  % loop to draw nested squares
  \foreach [count=\i] \lab in {rsc,nn,onen,mb,co,p2p,asy} {
    \draw (0,0) rectangle (\i+1,\i);
    \node[anchor=north east] at (\i+1,\i) {\lab};
  }
\end{tikzpicture}
\caption{Hierarchy of communication model semantics.}
\label{fig:coms}
\end{figure}

\paragraph{Causally ordered}
In the causally ordered (\verb|co|) communication model, messages are delivered 
to a process in accordance with the causal dependencies of their emissions. 
In other words, if there are two messages $m_1$ and $m_2$ with the same recipient, 
such that there exists a causal path from $m_1$ to $m_2$, then $m_1$ must be received 
before $m_2$. This notion of causal ordering was first introduced by Lamport under the 
name ``happened-before'' relation. In Figure~\ref{fig:p2p}, this 
causality is violated: $m_1$ should be received before $m_3$. Causal delivery 
is commonly implemented using Lamport's logical clock algorithm \cite{lamport2019time}.
Figure~\ref{fig:causalorder}, instead, respects the causal order of messages.

\begin{figure}[!ht]
	\centering
	\begin{msc}[draw frame=none, draw head=none, msc keyword=, 
				head height=0px, label distance=0.5ex, 
				foot height=0px, foot distance=0px]{}
		\declinst{p}{p}{}
		\declinst{q}{q}{}
		\declinst{r}{r}{}
		\declinst{s}{s}{}

		\mess[pos=0.1]{$m_4$}{p}{s}[4]
		\nextlevel
		\mess[pos=0.8]{$m_1$}{p}{q}
		\nextlevel
		\mess[pos=0.2]{$m_2$}{r}{q}
		\nextlevel
		\mess[pos=0.8]{$m_3$}{r}{s}
	\end{msc}
	\caption{An example of causal order semantic, that breaks mailbox order.}
	\label{fig:causalorder}
\end{figure}

\paragraph{Mailbox}
In this model, any two messages sent to the same process, regardless of the sender, 
must be received in the same order as they are sent. If a process receives $m_1$ 
before $m_2$, then $m_1$ must have been sent before $m_2$. \verb|mb| coordinates all 
the senders of a single receiver. This model is also called FIFO $n\!-\!1$.
However, the execution in Figure~\ref{fig:causalorder} does not respect mailbox semantics.  
In this example, the messages create a dependency cycle among the send events:  
$!m_4 \rightarrow !m_3 \rightarrow !m_2 \rightarrow !m_1 \rightarrow !m_4$.  
Such a cycle violates the order required by the mailbox model, since each 
send indirectly depends on its own completion. This circular dependency prevents 
the existence of any consistent ordering of message transmissions and receptions, 
breaking the communication model.

\paragraph{FIFO 1-n}
This model (\verb|onen|) is the dual of \verb|mb|, it coordinates a sender with all the 
receivers. Any two messages sent by a process must be received in the same 
order as they are sent. These two messages might be received by different 
processes and the two receive events might be concurrent.

\paragraph{FIFO n-n}
In this model (\verb|nn|), messages are globally ordered and delivered according to 
their emission order. Any two messages must be received in the same order 
as they are sent. These two messages might be sent or receives by any process 
and the two send or receive events might be concurrent. The FIFO \verb|n-n| 
coordinates all the senders with all the receivers. Figure~\ref{fig:finonn}
shows an example of this communication semantic.

\begin{figure}[!ht]
	\centering
	\begin{msc}[draw frame=none, draw head=none, msc keyword=, 
				head height=0px, label distance=0.5ex, 
				foot height=0px, foot distance=0px]{}
		\declinst{p}{p}{}
		\declinst{q}{q}{}
		\declinst{r}{r}{}

		\mess[pos=0.1]{$m_3$}{p}{r}[3]
		\nextlevel
		\mess[pos=0.8]{$m_1$}{p}{q}
		\nextlevel
		\mess[pos=0.2]{$m_2$}{r}{q}
	\end{msc}
	\caption{An example of FIFO n-n semantic.}
	\label{fig:finonn}
\end{figure}

\paragraph{RSC}
Figure~\ref{fig:coms} shows \verb|rsc| as the last block of the hierarchy.
\verb|rsc| stands for \emph{Realisable in Synchronous Communication}, therefore, 
is comparable to our definition of $\synchmodel$ model, but there are 
some differences. For example, it does not accept \emph{orphan messages}, 
which are instead accepted for the definition of this thesis.


\section{Realisability of MSCs and HMSCs}
In this section, we compare our framework with one of the earliest and
most influential works on realisability, the one of 
Alur~et~al.~\cite{alur2005realizability}, which also inspired part of our
approach. Their notion of \emph{Weak Realisability} captures the idea that
a specification of Message Sequence Charts (MSCs) should already include
all behaviours that are consistent with the local views of processes. 
Intuitively, a set of MSCs is weakly realisable when, for every process,
the events it observes in any MSC of the specification are compatible
with those in some MSC already in the set. This closure condition ensures
that the global behaviour can be reconstructed from the projections of
individual processes, so that every implied MSC is already part of the
language. 
% Alur~et~al. also provided an equivalent characterisation of
% weak realisability in terms of closure over prefixes of MSCs. 
Our own definition
of weak realisability coincides with theirs, as it expresses the same
fidelity concept over the local behaviour and abstracts from any
deadlock-related concern. In both cases, weak realisability focuses on
the alignment between local and global behaviours rather than on safety
properties such as deadlock-freedom. For safe realisability, we recall an
informal definition of Alur~et~al.~\cite{alur2005realizability} and discuss
the differences.

Intuitively, let $L$ be a set of MSCs. Then $L$ is said to be 
\emph{safely realisable} if there exists a family of concurrent automata 
$\langle A_i \mid 1 \leq i \leq n \rangle$ such that $L = L(\prod_i A_i)$ 
and the product automaton $\prod_i A_i$ is \emph{deadlock-free}. 
In this setting, a \emph{deadlock state} is a configuration of the global 
system from which no accepting state can be reached. 
This corresponds to a situation where all processes are 
waiting to receive messages that are no longer available in their 
communication buffers, preventing further progress. 
Hence, a system is deadlock-free if no such state is reachable from its 
initial configuration. This notion captures the safety aspect of 
realisability by ensuring that the system never reaches a globally 
stalled state during execution. This definition of safe realisability 
corresponds to ours in $\ppmodel$ or $\synchmodel$.

The work of Alur~et~al.~went on further, defining specific complexity classes 
for different kinds of assumptions. For finite sets of MSCs,
weakly realisability is shown to be \verb|coNP|-complete and safe 
realisability is shown to be decidable in \verb|P|-time. The problem
was subsequently studied for HMSCs. For \emph{bounded} HMSCs, safe realisability 
remains decidable, and it is \verb|EXPSPACE|-complete, but weak realisability 
becomes undecidable. For \emph{unbounded} HMSCs, 
safe realisability remains decidable, and it is \verb|EXPSPACE|-complete, but weak realisability 
becomes undecidable~\cite{alur2005realizability}. 
Later, Lohrey~et al.~\cite{lohrey2003realizability} proved in the general case, 
with a technique that involves five processes, that safe realisability 
is undecidable, though it is decidable (and \verb|EXPSPACE|-complete) 
for a specific kind of HMSCs, called globally-cooperative HMSCs, introducted 
in \cite{morin2002recognizable}.
Furthermore, in the context of weak realisability,
Genest et~al.~\cite{genest2006infinite} introduced the notion of
\emph{locally-cooperative} HMSCs, for which implementability can be
checked in linear time.
Since every globally-cooperative HMSC is also locally-cooperative,
verifying implementability for this broader class remains at least
\textbf{EXPSPACE}-hard, if it is decidable at all.
Lohrey~et al.~\cite{lohrey2003realizability} also considered another subclass of HMSC,
called $\mathcal{I}$-closed HMSC, whose checking safe realisability is \verb|PSPACE|-complete.
Most positive results assume other struttural restrictions, like bounded channels, 
but \cite{bollig2025high} introduces 
a new class of HMSCs that allows unbounded channels while maintaining realisability.

\section{Session Types}
Session Types provide a type-theoretic framework for specifying and verifying 
communication protocols among multiple participants.  
They ensure that interactions follow a predefined structure, 
preventing common concurrency errors such as deadlocks, orphan messages, 
and unspecified receptions. 
Session types were first formalised as 
\emph{Binary Session Types}~\cite{honda1993types}, 
which capture structured communication between two peers.  
The framework later evolved naturally into 
\emph{Multiparty Session Types (MPST)}~\cite{honda2008multiparty}, 
extending the theory to interactions among multiple participants.  
Over the years, session types have been integrated into several programming 
languages~\cite{ancona2016behavioral}, including 
Rust~\cite{jespersen2015session,chen2020ferrite}, 
Haskell~\cite{lindley2016embedding}, and 
Erlang~\cite{mostrous2011session}, 
broadening their practical relevance beyond purely theoretical models.  
They have also found applications across diverse domains such as 
operating systems~\cite{fahndrich2006language}, 
web services~\cite{yoshida2013scribble}, 
distributed algorithms~\cite{kouzapas2024session}, 
and smart contracts~\cite{das2021resource}.  

A \textbf{global type} defines the overall protocol, from which one 
derives the \textbf{local types} of each participant via a 
\emph{projection} operation.  
The system implementation, composed of communicating processes, is 
then verified against these local specifications using a 
\emph{typing system} and corresponding \emph{type-checking rules}, 
ensuring well-formed and safe behaviour.  
A key component of classical MPST is the \emph{merge operator}, 
which resolves non-determinism when projecting away interactions 
irrelevant to a participant.  
Since merging is only partially defined, it determines whether local 
states can be safely combined; when projection succeeds, it guarantees 
both deadlock freedom and protocol fidelity.  
Figure~\ref{fig:mpstschema} summarises the main elements of this framework.


\begin{figure}[!ht]
\centering
\begin{tikzpicture}[
      node distance=1.2cm,
      every node/.style={font=\sffamily},
      rect/.style={rectangle, draw=black, minimum width=1cm, minimum height=1cm},
      circ/.style={circle, draw=black, minimum size=1cm},
      arrow/.style={-{Stealth[scale=1.1]}, thick}
  ]

  % Nodes
  \node[rect] (G) {\textcolor{red}{$\mathcal{G}$}};
  \node[circ, below=of G] (TB) {\textcolor{blue}{$L_\text{B}$}};
  \node[circ, left=of TB] (TA) {\textcolor{blue}{$L_\text{A}$}};
  \node[circ, right=of TB] (TC) {\textcolor{blue}{$L_\text{C}$}};

  \node[rect, below=of TA] (PA) {\textcolor{brown}{$P_\text{A}$}};
  \node[rect, below=of TB] (PB) {\textcolor{brown}{$P_\text{B}$}};
  \node[rect, below=of TC] (PC) {\textcolor{brown}{$P_\text{C}$}};

  \node[rect,draw=none,right=of TC] (LC) {\textbf{\textcolor{blue}{2. Local type}}};
  \node[rect,draw=none,above=of LC] (LG) {\textbf{\textcolor{red}{1. Global type}}};
  \node[rect,draw=none,below=of LC] (LG) {\textbf{\textcolor{brown}{3. Processes}}};

  % Arrows
  \draw[arrow] (G) -- (TA) node[midway, left] {Projection};
  \draw[arrow] (G) -- (TB);
  \draw[arrow] (G) -- (TC);

  \draw[arrow] (PA) -- (TA) node[midway, left] {Type checking};
  \draw[arrow] (PB) -- (TB);
  \draw[arrow] (PC) -- (TC);
  \draw[arrow] (TC) -- (PC);
  \draw[arrow] (TB) -- (PB);
  \draw[arrow] (TA) -- (PA);

\end{tikzpicture}
\caption{Intuitive schema of MPST framework}
\label{fig:mpstschema}
\end{figure}

\subsection{Projectability}
\emph{Projectability} asks whether a global type can be faithfully 
projected into local specifications for each participant so that the 
resulting local types interact without mismatches or unintended 
behaviours.  
It therefore mirrors the \emph{realisability} problem studied in 
automata-theoretic settings, both concern whether a global specification 
admits a correct distributed implementation.

However, classical projection algorithms often reject natural yet safe 
protocols because of strong syntactic constraints designed to ensure 
safety.  
This gap between expressivity and implementability has motivated the 
search for more permissive definitions.  
Notably, the algorithm of Castagna et al.~\cite{castagna2012global} 
was the first to aim for \emph{full completeness}, balancing safety 
and expressiveness.

\subsubsection{Realisability and Restrictions in MPST}
Recent work connects MPST with automata-theoretic models such as High-level 
Message Sequence Charts (HMSCs). Stutz and Zufferey demonstrated that 
realisability is \textbf{decidable} for global types encoded as 
\emph{globally cooperative} HMSCs, a subclass preserving causal order through 
specific structural constraints~\cite{DBLP:journals/corr/abs-2209-10328,DBLP:conf/ecoop/Stutz23}.  
Li et al.~\cite{li2023complete} later introduced a complete projection operator 
ensuring correctness for all implementable global types.  

In his thesis, Stutz~\cite{stutz2024implementability} provides a comprehensive 
classification of the \textbf{syntactic restrictions} that govern both 
\emph{expressivity} and \emph{decidability} in MPST.  
He generalises the traditional notion of sender-driven choice to allow a sender 
to branch towards different receivers, capturing common distributed patterns 
such as delegation or load balancing, while keeping the implementability 
problem \textbf{decidable} in \verb|PSPACE|.  
This establishes the first tight complexity bound for the class of 
sender-driven global types and confirms that they can be faithfully 
represented as HMSCs.  
Note that Stutz~et~al.\ interpret \emph{deadlocks} in the sense of our
\emph{progress} property, and additionally define \emph{soft deadlocks}
for its model.
The latter gives rise to the \emph{soft implementability} problem.

A key syntactic dimension in MPST is how \emph{choice} is handled 
when a branch of the protocol is encountered, as this 
determines whether projection and realisability remain decidable.  
The three main variants are:
\begin{itemize}
    \item \emph{Directed choice}: every branch shares the same 
    sender–receiver pair, yielding a single decision point.  
    This ensures safety and straightforward projection but severely limits 
    expressivity, as many distributed coordination patterns are 
    excluded~\cite{honda2008multiparty}.  

    \item \emph{Sender-driven choice}: each branch has a single sender, 
    but receivers may differ across branches.  
    This generalisation captures richer interaction schemes while retaining 
    decidability; as mentioned, safe realisability for this fragment lies in 
    \verb|PSPACE|~\cite{stutz2024implementability}.  

    \item \emph{Mixed choice}: multiple senders may initiate branches 
    concurrently, removing a unique decision-maker.  
    While this maximises expressivity, it introduces intrinsic 
    nondeterminism in control flow, making implementability and its 
    weaker variants (e.g., soft or weak realisability) \textbf{undecidable} 
    in general~\cite{stutz2024implementability}.  
\end{itemize}

These results precisely delineate the boundary between expressivity and 
decidability in MPST.  
Stutz’s framework provides the first complete algorithmic account of 
implementability for sender-driven global types and proves that no 
complete algorithm can exist once mixed choice is permitted.


\section{Choreographies}
Choreographies \cite{ws-cdl-2005} and Choreographic 
Programming~\cite{montesi2014choreographic, giallorenzo2024choral, cruz2022functional} 
are other formalisms to describe  
distributed communication protocols. Choreographies emphasize the 
global specification of interactions as a high-level description of the 
intended message exchanges. Similarly to MPST, their goal is to ensure that
a distributed implementation can be derived in which each participant 
follows a local behaviour consistent with the global description, called
respectively \emph{local} and \emph{global}-view. This setting naturally 
connects to the realisability problem, since the key question is whether 
a choreography can be faithfully implemented by a system of local 
processes. 
In choreographies, the local-view is called 
\textbf{End-Point Projection} (EPP),
and it is derived via a projection operation from the global-view.
In particular, \emph{Choreography Automata}~\cite{barbanera2020choreography}  
share many conceptual similarities with our notion of Global Types.  
Both formalisms model global interaction structures through automata  
over communication actions, capturing the causal dependencies among  
participants. The main difference lies in the underlying semantics and  
the intended use: Choreography Automata focus on synthesis and  
verification within choreographic frameworks, while our Global Types  
are tailored to the study of realisability under different
communication semantics.  

One important challenge studied in choreographic design is the 
\textbf{knowledge of choice} problem~\cite{lanese2008bridging, castagna2012global}. 
This problem can be seen as a 
specific instance of the general projection problem: it arises when 
translating a global description into consistent local behaviours. 
In particular, it captures the difficulty of maintaining coherence 
when decisions made by one participant must be known by others.  

Informally, a choreography has knowledge of choice if, whenever a 
branching (conditional) decision is made by one participant, all 
other affected participants are made aware of that decision. Without 
proper communication of the choice, a participant may behave 
inconsistently because it lacks information to distinguish which 
branch was taken. For example, if process \(A\) chooses between two 
branches that lead to different sub-protocols with process \(B\), 
then \(B\) must receive a signal (a ``selection'') that lets it 
synchronize on the correct continuation.  

If the choreography lacks such a mechanism, it becomes 
\emph{unprojectable}: EPP cannot generate local behaviours that 
correctly coordinate the branching. This issue 
is addressed, typically, by adding explicit selection messages to 
propagate the choice, and how this can be automated via 
\emph{amendment} or \emph{repair} algorithms 
\cite{DBLP:journals/corr/LaneseMZ13, basu2016automated}, 
which insert minimal extra 
communications to guarantee knowledge of choice.  

Conceptually, this problem is closely related to the \emph{sender-driven 
choice} policy highlighted before in the MPST framework, where 
multiple senders make independent choices that must be reconciled to 
ensure a coherent global behaviour. In both cases, the challenge lies 
in ensuring that all participants have sufficient knowledge to follow 
the same branch, preserving consistency across local projections. 


\section{Other works}
In his thesis~\cite{stutz2024implementability}, 
Stutz further investigate which syntactic and semantic
restrictions in global types are \emph{non-restrictive}, that is, those that
do not compromise expressivity while preserving decidability.  
Stutz et al.~introduce
\emph{Protocol State Machines} (PSMs)~\cite{stutz2025automata}, 
a unifying automata-theoretic
formalism that strictly generalises both Global Types and HMSCs.  
This model captures interaction protocols as communicating state
machines over message-passing labels, bridging automata theory and MPST.
His results show that every sink-final $\Sigma 1$-PSM can be represented
as a non-deterministic Global Type that preserves sender-driven or
mixed-choice behaviour~\cite[Thm.~8.14]{stutz2024implementability}.  
Later, Stutz et~al.~\cite{stutz2025automata} extended this line of work,
formalising PSMs and analysing the computational complexity of type
checking and realisability. They demonstrate that, for choice-free or
single-choice fragments, both problems remain decidable (often in
\verb|PTIME|), whereas the introduction of \emph{mixed choice} renders
realisability \emph{undecidable}.  
Together, these results reinforce the view that structural constraints
such as single recursion points or explicit termination are
\emph{expressively harmless}, while the distinction between
\emph{sender-driven} and \emph{mixed} choice constitutes the true
boundary between decidability and undecidability in distributed protocol
implementations.

Another relevant contribution is by Guanciale et al.~ 
\cite{DBLP:journals/jlap/GuancialeT19}, who study the 
\emph{realisability of pomsets} via communicating automata. 
Pomsets, or partially ordered multisets, generalise MSCs by 
capturing causal dependencies among events rather than total 
orders. Their work defines realisability conditions ensuring 
both communication correctness and termination soundness, 
supporting participants with internal concurrency.
Table~\ref{tab:realisability-summary} summarises the 
main results analised in the last sections. To our knowledge, 
empty cells are to be considered open problems, like
the safe realisability problem for sender-driven HMSCs
and PSMs.

\bigskip

\begin{table}[!ht]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|p{4.3cm}|p{4.3cm}|p{4.3cm}|}
\hline
\textbf{Formal Model} & \textbf{Weak Realisability} & \textbf{Safe Realisability} \\ 
\hline
\textbf{Finite sets of MSCs} 
& coNP-complete~\cite{alur2005realizability} 
& P-time~\cite{alur2005realizability} \\ 
\hline
\textbf{Unbounded HMSCs} 
& Undecidable~\cite{lohrey2003realizability} 
& Undecidable~\cite{lohrey2003realizability} \\ 
\hline
\textbf{Bounded HMSCs (FIFO)} 
& Undecidable~\cite{alur2005realizability} 
& EXPSPACE-complete~\cite{lohrey2003realizability} \\ 
\hline
\textbf{Bounded HMSCs (non-FIFO)} 
& Decidable~\cite{morin2002recognizable} 
& EXPSPACE-complete~\cite{lohrey2003realizability} \\ 
\hline
\textbf{Globally-Cooperative HMSCs} 
& -- 
& EXPSPACE-complete~\cite{morin2002recognizable} \\ 
\hline
\textbf{Locally-Cooperative HMSCs} 
& Linear time~\cite{genest2006infinite}
& At most EXPSPACE-complete~\cite{morin2002recognizable}  \\ 
\hline
\textbf{$\mathcal{I}$-Closed HMSCs} 
& -- 
& PSPACE-complete~\cite{lohrey2003realizability} \\ 
\hline
\textbf{Loop-connected HMSCs (unbounded channels)} 
& -- 
& Decidable~\cite{bollig2025high} \\ 
\hline
\textbf{MPST (directed choice)} 
& --
& Decidable, but incomplete~\cite{honda2008multiparty} \\ 
\hline
\textbf{MPST (sender-driven choice)} 
& --
& PSPACE-complete~\cite{stutz2024implementability} \\ 
\hline
\textbf{MPST (mixed choice)} 
& Undecidable~\cite{stutz2024implementability} 
& Undecidable~\cite{stutz2024implementability} \\ 
\hline
\textbf{General PSMs} 
& --
& Undecidable~\cite{stutz2025automata} \\ 
\hline
\textbf{Choreographic Programming} 
& --
& Decidable~\cite{barbanera2020choreography} \\ 
\hline
\end{tabular}
\caption{Summary of computational complexity for weak and safe realisability across formal models.}
\label{tab:realisability-summary}
\end{table}

\section{Related Tools}\label{sec:reltool}
Several verification tools have been developed to analyse communicating 
automata and distributed systems under asynchronous or bounded communication 
semantics. 

\textsc{McScM}~\cite{heussner2012mcscm} is the tool most closely related 
to \textsc{ReSCu}. It takes as input a system description and a set of 
\emph{bad configurations} (expressed using Queue Decision Diagrams, QDDs, 
from~\cite{boigelot1996symbolic}) and checks their reachability. 
The tool implements multiple model-checking strategies based on abstract 
interpretation~\cite{cousot1977abstract} and supports general classes of communicating systems.  
In contrast to \textsc{ReSCu}, most approaches in \textsc{McScM} are 
\emph{semi-algorithms}, requiring user-defined timeouts to terminate.  
However, its strength lies in providing a diverse set of verification 
engines, which increases the likelihood of obtaining conclusive verification 
results.  
Notably, \textsc{ReSCu} reuses the same input description language as 
\textsc{McScM}, ensuring compatibility and easing system specification.

\textsc{KMC}~\cite{lange2019verifying} (for \emph{k-Multiparty 
Compatibility}) was introduced by Lange and Yoshida to verify whether a 
system could have been derived from a \emph{Multiparty Session Type} (MPST).  
If a system satisfies $k$-MC, several safety properties, such as freedom from 
deadlock and orphan messages, are guaranteed automatically.  
Unlike \textsc{ReSCu} and \textsc{McScM}, \textsc{KMC} does not require the 
explicit specification of safety conditions but relies on the theoretical 
guarantees of MPST projection.

The \textsc{STaB-C} tool~\cite{akroun2018automated,akroun2016automated} 
implements semi-algorithms for checking \emph{k-stability}, a property that 
guarantees behavioural equivalence across different communication bounds.  
A system is $k$-stable if, for any larger bound $k' > k$, its behaviour 
remains equivalent (under various notions of trace or observational 
equivalence).  
While \textsc{STaB-C} focuses on detecting stability rather than verifying 
safety or liveness, it provides important insight into boundedness and 
behavioural robustness of FIFO systems.  
Unlike \textsc{ReSCu}, which verifies multiple semantic properties such as 
deadlock-freedom and progress, \textsc{STaB-C} focuses exclusively on 
membership in the class of $k$-stable systems.
