\chapter{Weak-Realisability is Undecidable for Synchronous Global Types}
\label{sec:proof}

This chapter presents the first main contribution of this thesis, formalised in
Theorem~\ref{thm:main}, which establishes that 
\emph{Weak-realisability is undecidable for synchronous global types}.  
This result complements the broader reduction theorem introduced in
Section~\ref{sec:red}, where we showed how the realisability problem for
peer-to-peer systems can be reduced to the study of realisability under
synchronous semantics.  
Here, we focus exclusively on this synchronous setting, proving that even in such
a constrained communication model, weak realisability remains undecidable.

To support this proof, Chapter~\ref{sec:pre} introduced the necessary background on
Message Sequence Charts (MSCs), Global Types, and Weak-realisability.  
In this chapter, we build upon those foundations by formally defining the
core constructions used in the proof of Theorem~\ref{thm:main}.  
The proof itself is inspired by the classical reduction of 
Alur et~al.~\cite{alur2005realizability}, which we extend and adapt to the
framework of synchronous global types.  
Along the way, we emphasise the main conceptual and technical differences
between our approach and the original construction, clarifying how these 
adaptations enable the result to hold in the synchronous semantic setting.

\section{Definitions}
The proof is a \emph{reduction} from the
\textbf{Relaxed Post Correspondence Problem (RPCP)}, a variant of
the classical Post Correspondence Problem (PCP). 
RPCP was shown to be undecidable by
Alur~et~al.~\cite{alur2005realizability}, via reduction from PCP.
The main idea is to encode the existence of a
solution to an RPCP instance into the non-realisability of our formal
specification. In the original proof, MSCs are directly used to build an
HMSC called $M^*$. In our case, we will define a
\emph{global type} (called $L^*$) built from global types.
A generic solution for the RPCP problem will correspond to the global
type $L^*$. Therefore, we need to prove:
$$
\Delta \in \text{RPCP} \quad\iff\quad L^* \text{ is not realisable}.
$$

\bigskip

\begin{definition}[Relaxed Post Correspondence Problem]
	Given a set of tiles $\{(v_1, w_1), (v_2, w_2), ..., (v_r, w_r)\}$, 
	determining whether there exist indices $i_1, ..., i_m$ such that
	$$x_{i_1}\cdots x_{i_m} = y_{i_1}\cdots y_{i_m},$$
	where $x_{i_j}, y_{i_j} \in \{v_{i_j}, w_{i_j}\}$, such that:
	\begin{itemize}
		\item there exists at least one index $i_\ell$ for which $x_{i_\ell}\neq y_{i_\ell}$, and
		\item for all $j \leq m$, $y_{i_1}\cdots y_{i_j}$ is a strict or 
		not-strict prefix of $x_{i_1}\cdots x_{i_j}$.
	\end{itemize}
\end{definition}

Intuitively, RPCP requires that the concatenation on the left-hand side always 
grows at least as fast as the right-hand side, while ensuring that at least one 
chosen tile differs between the two sequences. Moreover, in constructing the 
strings, we may freely choose which element of each tile (either $v_i$ or $w_i$) 
contributes to the left or right sequence.

\bigskip

\begin{example}[Simple RPCP instance]\label{exmp:rpcp}
Consider the tile set
\[
(v_1,w_1)=(\texttt{b},\ \texttt{bb}),\quad
(v_2,w_2)=(\texttt{a},\ \texttt{ab}),\quad
(v_3,w_3)=(\texttt{c},\ \texttt{c}).
\]
Take the index sequence $(2,1,3)$ and the choices
\[
x_1 = w_2,\ y_1 = v_2;\quad
x_2 = v_1,\ y_2 = w_1;\quad
x_3 = v_3,\ y_3 = w_3.
\]
Then
\[
x_1 x_2 x_3 = \texttt{ab}\ \texttt{b}\ \texttt{c} = \texttt{abbc},
\qquad
y_1 y_2 y_3 = \texttt{a}\ \texttt{bb}\ \texttt{c} = \texttt{abbc},
\]
so the two sides are equal.

We now check the RPCP conditions:
\begin{itemize}
  \item \textbf{at least one mismatch:} here $x_1\neq y_1$ and
        $x_2\neq y_2$, so the ``some index differs'' condition holds;
  \item \textbf{prefix property:} for every prefix length $j$ we have
        $y_{1}\cdots y_{j}$ is a prefix of $x_{1}\cdots x_{j}$:
        \begin{itemize}
          \item $j=1$: $y_1=\texttt{a}$ is a prefix of $x_1=\texttt{ab}$;
          \item $j=2$: $y_1y_2=\texttt{abb}$ is a prefix of $x_1x_2=\texttt{abb}$;
          \item $j=3$: $y_1y_2y_3=\texttt{abbc}$ is a prefix of $x_1x_2x_3=\texttt{abbc}$.
        \end{itemize}
\end{itemize}
\end{example}

\bigskip

We have now identified the main problem to which our proof reduces.  
The next step is to encode an RPCP instance into the formal model.
In the original proof, MSCs are used, but, in our case, we also need to give
an encoding using Global Types. We will first give the MSC one.

\bigskip

\begin{definition}[$M^n_i$]\label{def:mni}
	Given the index $i$ of a tile $(v_i, w_i)$, and
	given an interger $n\in\{0,1\}$, where:
	\begin{itemize}
		\item if $n=0$, then $x_i=v_i$;
		\item if $n=1$, then $x_i=w_i$;
	\end{itemize}
	The behavior of the MSC $M^n_i$ is as follows:
	first, Process~1 synchronously sends message
	$m_1 = (i, n)$ to Process~2, then Process~1 transmits the index $m_2=i$
	to Process~4. Subsequently, Process~4 sends $m_3 = (i, n)$
	synchronously to Process~3. After these control messages, Process~2
	sends the characters $m_i^1 = x_i^1,..., m_i^c = x_i^c$
	synchronously to Process~3 (where $c$ is the length of $x_i$).
	This MSC is depicted in Figure~\ref{fig:mni}, 

	\begin{figure}[!ht]
		\centering
		\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
			\declinst{P1}{P1}{}
			\declinst{P2}{P2}{}
			\declinst{P3}{P3}{}
			\declinst{P4}{P4}{}

			\syncmscmess{$(i,n)$}{P1}{P2}
			\syncmscmess{$i$}{P1}{P4}
			\syncmscmess{$(i,n)$}{P4}{P3}
			\syncmscmess{$x_i^1$}{P2}{P3}
			\syncmscmess{...}{P2}{P3}
			\syncmscmess{$x_i^c$}{P2}{P3}
		\end{msc}
		\caption{The $M_i^n$ MSC.}
		\label{fig:mni}
	\end{figure}

\end{definition}

Given a RPCP instance $\{(v_1,w_1),\ldots,(v_m,w_m)\}$, we associate  
with each pair $(v_i,w_i)$ two MSCs $M^0_i$ and $M^1_i$, following  
Definition~\ref{def:mni}. Each MSC $M^n_i$ is \emph{synchronous}  
(Lemma~\ref{lemma:minsynch}). Intuitively, the MSC $M_i^n$ encodes the  
construction of a string given some tiles through the interaction of four processes.  
Processes~2 and~3 are responsible for building the string itself,  
while Processes~1 and~4 transmit the index information to Processes~2  
and~3, respectively. In particular, Process~1 initiates the choice and  
forwards it to Process~4. This encoding applies equally to definition~\ref{def:gni}.

\bigskip

\begin{lemma}\label{lemma:minsynch}
The MSC $M_i^n$ belongs to $\mscsetofmodel{\synchmodel}$.
\end{lemma}

\begin{proof}
By Definition~\ref{def:msc}, each communication in $M_i^n$
consists of a send event $\send{p}{q}{m}$ and its corresponding
receive event $\recv{p}{q}{m}$, with $\source(\recv{p}{q}{m}) =
\send{p}{q}{m}$.  
By Definition~\ref{def:synchronous}, an MSC is synchronous
if there exists a linearisation in which every send event
immediately precedes its matching receive.

In $M_i^n$, the set of messages exchanged is
\[
\{\, m_1, m_2, m_3, m_i^1, \ldots, m_i^c \,\},
\]
with $c = |x_i|$.  
A valid synchronous linearisation therefore exists and is given by:
\[
!m_1 ?m_1\;\; !m_2 ?m_2\;\; !m_3 ?m_3\;\;
!m_i^1 ?m_i^1 \;\ldots\; !m_i^c ?m_i^c.
\]
This linearisation satisfies the synchronous ordering constraint,
as every send is immediately followed by its matching receive.
Hence, by Definition~\ref{def:linearisable-msc},  
$M_i^n \in \mscsetofmodel{\synchmodel}$.
\end{proof}

We now define how to obtain a Global Type on top of an MSC.

\bigskip

\begin{definition}[$\gt_M$]\label{def:gm}
Let $M \in \mscsetofmodel{\synchmodel}$ be a message sequence chart (MSC)  
over the set of processes $\Procs$ and messages $\Messages$.  
We construct the corresponding Global Type $\gt_M = (Q, \Sigma, \delta, q_0, F)$  
as follows.

\begin{itemize}

    \item
    The alphabet $\Sigma$ is the set of \emph{synchronous communication arrows}  
    \[
        \Sigma = \{\, \marrow{p}{q}{m} \mid 
        \exists \, \event_s \in \sendeventsof{M}, \, 
        \event_r \in \receiveeventsof{M} \text{ such that }
	\]
    \[
        \source(\event_r) = \event_s, \, 
        \processof{\event_s}=p, \, \processof{\event_r}=q, \, 
        \messageof{\event_s}=m \,\}.
    \]

    \item
    Since $M \in \mscsetofmodel{\synchmodel}$, there exists a  
    \emph{synchronous linearisation}  
    $w = \alpha_1 \alpha_2 \ldots \alpha_k$,  
    where each $\alpha_j = \marrow{p_j}{q_j}{m_j} \in \Sigma$  
    represents a complete synchronous communication step (send immediately  
    followed by its matching receive).

    \item
    Let $Q = \{ q_0, q_1, \ldots, q_k \}$,  
    where $q_0$ is the initial state and $q_k$ is the unique accepting state.

    \item
    The transition function $\delta : Q \times \Sigma \to Q$  
    is defined sequentially along the synchronous interactions of $M$:  
    \[
        \forall j \in \{1, \ldots, k\}, \quad  
        \delta(q_{j-1}, \alpha_j) = q_j.
    \]
    All other transitions are undefined.

\end{itemize}

\end{definition}

Intuitively, $\gt_M$ captures the exact synchronous execution order of $M$:  
it is the deterministic automaton that accepts the single word  
$w = \alpha_1 \alpha_2 \ldots \alpha_k$ over $\Sigma$,  
representing the sequence of message exchanges in $M$.  
Equivalently, $\gt_M$ recognises the set of MSCs whose synchronous  
linearisations are $w$.
We now use this definition to encode $M_i^n$ in a Global Type format.

\bigskip

\begin{definition}[$G_i^n$]\label{def:gni}
Let $(v_i, w_i)$ be a tile and $n \in \{0,1\}$.  
Set $x_i = v_i$ if $n = 0$, and $x_i = w_i$ if $n = 1$.  
Let $c = |x_i|$ and write $x_i = x_i^1 x_i^2 \cdots x_i^c$.

The global type $G_i^n$ (shown in Figure~\ref{fig:gni}) is the DFA
$G_i^n = (Q, \Sigma, \delta, q_0, F)$, obtained
on top of the MSC $M_i^n$ (Definition~\ref{def:mni}) using the 
construction in Definition~\ref{def:gm}, and defined as follows:
\begin{itemize}
	\item $\mathbb{P} = \{P1, P2, P3, P4\}$;
	\item $\mathbb{M} = \{m_1, m_2, m_3, m_{x_i^1}, \ldots, m_{x_i^c}\}$,
	      where $m_1 = (i, n)$, $m_2 = i$, $m_3 = (i, n)$, and
	      $m_{x_i^j} = x_i^j$ for $1 \le j \le c$;
	\item $\text{Arr} = \{\,$\arrmess{P1}{P2}{m_1}$,\, $\arrmess{P1}{P4}{m_2}$,\,
	      $\arrmess{P4}{P3}{m_3}$,\, $\arrmess{P2}{P3}{m_{x_i^1}}$, \ldots,
	      $\arrmess{P2}{P3}{m_{x_i^c}}$\,\}$, where each arrow denotes
	      a synchronous message with acknowledgment;
	\item $Q = \{q_0, q_1, q_2, q_3, q_4, \ldots, q_{3+c}\}$,  
	      where $q_0$ is the initial state and  
	      $F = \{q_{3+c}\}$ is the unique accepting state;
	\item The alphabet $\Sigma$ is the finite set of arrows (synchronous message labels):  
	      $
	      \Sigma = 
	      \{\,$\arrmess{P1}{P2}{m_1}$,\,
	           $\arrmess{P1}{P4}{m_2}$,\,
	           $\arrmess{P4}{P3}{m_3}$\,\}
	      \cup
	      \{\,$\arrmess{P2}{P3}{m_{x_i^j}}$ \mid 1 \le j \le c\,\}.
	      $
	\item The (deterministic) transition function
	      $\delta : Q \times \Sigma \to Q$ is defined by:
	        $  \delta(q_0,\, $\arrmess{P1}{P2}{m_1}$) = q_1,\ 
	          \delta(q_1,\, $\arrmess{P1}{P4}{m_2}$) = q_2, \ 
	          \delta(q_2,\, $\arrmess{P4}{P3}{m_3}$) = q_3, \ 
	          \delta(q_{2+j},\, $\arrmess{P2}{P3}{m_{x_i^{j+1}}}$) = q_{3+j}, 
	          \  0 \le j < c.$
	      Hence, the sequence of transitions from $q_3$ to $q_{3+c}$ 
	      corresponds to the synchronous exchanges between $q$ and $r$
	      labelled by $m_{x_i^1}, \ldots, m_{x_i^c}$.
\end{itemize}

	\begin{figure}[!ht]
		\centering
		\begin{tikzpicture}[->, node distance=35mm, on grid, auto]
			\node[state] (q0) {$q_0$};
			\node[state] (q1) [right=of q0] {$q_1$};
			\node[state] (q2) [right=of q1] {$q_2$};
			\node[state] (q3) [below left=of q0] {$q_3$};
			\node[state] (q4) [right=of q3] {$q_4$};
			\node[state] (q5) [right=of q4] {$\cdots$};
			\node[state,accepting] (q6) [right=of q5] {$q_x$};

			\path (q0) edge[] node[above] {\arrmess{P1}{P2}{(i,n)}} (q1);
			\path (q1) edge[] node[above] {\arrmess{P1}{P4}{i}} (q2);
			\path (q2) edge[] node[above left] {\arrmess{P4}{P3}{(i,n)}} (q3.60);
			\path (q3) edge[] node[above] {\arrmess{P2}{P3}{x_i^1}} (q4);
			\path (q4) edge[] node[above] {\arrmess{P2}{P3}{...}} (q5);
			\path (q5) edge[] node[above] {\arrmess{P2}{P3}{x_i^c}} (q6);
		\end{tikzpicture}
		\caption{The global type $G_i^n$.}
		\label{fig:gni}
	\end{figure}

\end{definition}

% Intuitively, $G_i^n$ specifies the same communication pattern as the MSC  
% $M^n_i$ introduced in Definition~\ref{def:mni}. This structural  
% correspondence will be made precise in the next lemma (Lemma~\ref{lem:gm}).  

Intuitively, using the costruction defined in Definition~\ref{def:gm},
we obtain a Global Type whose existential language of representation
correspond exactly to the given MSC. 

\bigskip

\begin{lemma}\label{lem:gm}
For every MSC $M \in \mscsetofmodel{\synchmodel}$,  
there exists a Global Type $\gt_M$ such that  
$\existentialmsclanguageof{\gt_M} = \{ M \}$.
\end{lemma}

\begin{proof}
Let $M \in \mscsetofmodel{\synchmodel}$ and let $\gt_M$ be the Global Type  
constructed as in Definition~\ref{def:gm}.  
By definition, $\gt_M$ is the DFA that accepts exactly  
the synchronous linearisation  
$w = \alpha_1 \alpha_2 \ldots \alpha_k$ of $M$,  
where each $\alpha_j = \marrow{p_j}{q_j}{m_j}$  
corresponds to a complete synchronous communication.  
Since every execution of $\gt_M$ under the synchronous semantics  
follows the exact sequence of communications in $w$,  
it induces the same causal and message relations as in $M$.  
Hence, the unique MSC corresponding to any accepting run of $\gt_M$  
is precisely $M$.  
Conversely, any MSC $M'$ whose synchronous linearisation is accepted  
by $\gt_M$ must have the same sequence of synchronous interactions as $M$,  
and therefore $M' = M$.  
Therefore, the existential MSC-language of $\gt_M$ contains exactly $M$,  
that is,
\[
    \existentialmsclanguageof{\gt_M} = \{ M \}.
\]
\end{proof}


Lemma~\ref{lem:gm} establishes a direct correspondence between a  
single synchronous MSC and a Global Type. In particular, every  
synchroonus MSC can be captured precisely by a Global Type whose  
language contains only that MSC. This correspondence will be useful  
when embedding RPCP instances into the Global Type framework.
We now introduce a more structured Global Type, parameterized by a  
string $S$, which will serve as the building block in the reduction.

Thanks to Lemma~\ref{lem:gm} and given that $M_i^n$
is a synchronous MSC (Lemma~\ref{lemma:minsynch}), 
we can establish now that 
$\existentialmsclanguageof{G_i^n} =\{M_i^n\}$.
After establishing the connection between the MSC's encoding and
Global Type's encoding,
we briefly summarize the rationale behind the design of $M_i^n$ and $G_i^n$.

Suppose that $\Delta=(i_1,a_1,b_1,\ldots,i_m,a_m,b_m)$ is a  
solution to the RPCP instance. From this solution we construct   
two MSCs sequences:
\[
M_x = M^{a_1}_{i_1}\cdots M^{a_m}_{i_m}, \qquad  
M_y = M^{b_1}_{i_1}\cdots M^{b_m}_{i_m}.
\]
Both $M_x$ and $M_y$ are concatenations of synchronous  
MSCs. We then define a third MSC $M_{\texttt{sol}}$, obtained by  
projecting $M_y$ onto processes $P1,P2$ and $M_x$ onto processes  
$P3,P4$. Intuitively, processes $P1,P2$ represent the construction of  
the \emph{right-hand string} $y_{i_1}\cdots y_{i_m}$, while processes  
$P3,P4$ represent the construction of the \emph{left-hand string}  
$x_{i_1}\cdots x_{i_m}$. The prefix property of RPCP guarantees that  
$M_{\texttt{sol}}$ is acyclic and \emph{synchronous}. Establishing that 
$M_{\texttt{sol}} \in \mscsetofmodel{\synchmodel}$ is non-trivial, and this 
step is an addition to the original proof. 

% With these constructions in place, we proceed to introduce the main  
% objects used in the proof. Specifically, we first show how a Global  
% Type can represent a single \verb|synch| MSC.

% \bigskip

% \begin{lemma}\label{lmm:msgs}
% Assume $\acommunicationmodel$ is the $\synchmodel$ model and $i,n$ are integers.
% The MSC $M^n_i$ (Definition~\ref{def:mni}) is included in 
% $\msclanguageof{G_i^n}{\synchmodel}$ (Definition~\ref{def:gni}).
% \end{lemma}

% % TODO: Da rifare meglio, non ha senso quel L(M) = L(G)
% \begin{proof}
% 	Both $M^n_i$ and $G_i^n$ describe the same communication structure:
% 	process $p$ sends $(i,n)$ to $q$ and $i$ to $s$;
% 	process $s$ relays $(i,n)$ to $r$;
% 	process $q$ then sends the characters of $x_i$ to $r$.
% 	The sequence of messages is identical in both 
% 	$M^n_i$ and $G_i^n$. Since both models enforce synchronous communication, 
% 	their linearisations coincide. 
% 	Hence, $M^n_i \in \msclanguageof{G_i^n}{\synchmodel}$.
% \end{proof}

% Having established the correspondence between an individual MSC and its
% associated global type, we now extend this construction to sets of global
% types. 
The following definition introduces the global type $L^*$, which
encapsulates all possible compositions derived from a given RPCP instance.
Intuitively, for each MSC $M \in \setmsc$, there exists a corresponding
global type $G \in G^*$ that captures the behaviour described by $M$.
The automaton defining $L^*_N$ then combines all such global types in $G^*$
into a single structure, allowing transitions between them through
$\varepsilon$-moves. The determinisation of this automaton yields the
global type $L^*$, representing the full set of possible interactions
generated by the collection of MSCs.

\bigskip

\begin{definition}[The $L^*$ global type]\label{def:lstar}
	Given an instance $\{(v_1, w_1), \ldots, (v_m, w_m)\}$ of RPCP, we
	construct a set $M^* = \{M_i^0, M_i^1 \mid i \in \{1, \ldots, m\}\}$ of
	MSCs over four processes as follows. For each pair $(v_i, w_i)$,
	we define two MSC, $M_i^0$ and $M_i^1$, as specified in
	Definition~\ref{def:mni} and illustrated in Figure~\ref{fig:mni}.
	For each MSC in $M^*$, we construct $G^*$ using Definition~\ref{def:gm}.
	Every Global Type in $G^*$ is shaped like Definition~\ref{def:gni} 
	(shown in Figure~\ref{fig:gni}).
	We define the global type $L^*_{N}$ as the automaton
	$\mathcal A = (Q,\Sigma, \delta, l_0, F)$ where:
	\begin{itemize}
		\item $Q = \{v_I,v_T\}\cup \bigcup_{G\in G^*} Q^G$;
		\item $\Sigma = \{\epsilon\}\cup\bigcup_{G\in G^*} \Sigma^G$;
		\item $\delta: Q \times \Sigma \rightarrow 2^Q$ is defined by:
			      \begin{enumerate}
				       \item $\forall G \in G^*,\ \delta(v_I, \varepsilon) = q_0^G$ where $q_0^G$ is the initial state of $G$,
				       \item $\forall G \in G^*,\ \forall q_f^G \in F^G,\ \delta(q_f^G, \varepsilon) = v_T$,
				       \item $\forall G, G' \in G^*,\ \forall q_f^G \in F^G,\ \delta(q_f^G, \varepsilon) = q_0^{G'}$.
			      \end{enumerate}
		\item $l_0 = v_I$ is the initial state;
		\item $F = v_T$ is the accepting state.
	\end{itemize}
	The automaton of $L^*_{N}$ is shown in Figure~\ref{fig:lstar}.  
	Finally, the Global Type $L^*$ is obtained as the determinisation 
	of $L^*_{N}$ (Definition~\ref{def:det}).
\end{definition}

\begin{figure}[!ht]
	\centering
	\begin{tikzpicture}[->, node distance=35mm, on grid, auto]
		\node[state] (vI) {$v_I$};
		\node[state] (qI2) [right=of vI] {$\cdots$};
		\node[state] (qI1) [above=of qI2] {$q_0^{G^1}$};
		\node[state] (qI3) [below=of qI2] {$q_0^{G^n}$};
		\node[state] (qM1) [right=of qI1] {$\cdots$};
		\node[state] (qM2) [right=of qI2] {$\cdots$};
		\node[state] (qM3) [right=of qI3] {$\cdots$};
		\node[state] (qF1) [right=of qM1] {$q_f^{G^1}$};
		\node[state] (qF2) [right=of qM2] {$\cdots$};
		\node[state] (qF3) [right=of qM3] {$q_f^{G^n}$};
		\node[state,accepting] (vT) [right=of qF2] {$v_T$};

		\path (vI) edge[] node[above] {$\epsilon$} (qI1);
		\path (vI) edge[] node[above] {$\epsilon$} (qI2);
		\path (vI) edge[] node[above] {$\epsilon$} (qI3);
		\path (qI1) edge[] node[above] {\arrmess{p}{q}{(i^{G^1},n^{G^1})}} (qM1);
		\path (qI2) edge[] node[above] {} (qM2);
		\path (qI3) edge[] node[above] {\arrmess{p}{q}{(i^{G^n},n^{G^n})}} (qM3);
		\path (qM1) edge[] node[above] {\arrmess{q}{r}{x^{G^1}_c}} (qF1);
		\path (qM2) edge[] node[above] {} (qF2);
		\path (qM3) edge[] node[above] {\arrmess{q}{r}{x^{G^n}_c}} (qF3);
		\path (qF1) edge[] node[above] {$\epsilon$} (vT);
		\path (qF2) edge[] node[above] {$\epsilon$} (vT);
		\path (qF3) edge[] node[above] {$\epsilon$} (vT);
		
		\draw (qF1.135) to [bend right=30] node[above] {$\epsilon$} (qI1.45);
		\draw (qF2.135) to [bend right=30] node[above] {$\epsilon$} (qI2.45);
		\draw (qF3.135) to [bend right=30] node[above] {$\epsilon$} (qI3.45);

		\draw (qF1.225) to node[above] {$\epsilon$} (qI2.60);
		\draw (qF3.120) to node[above] {$\epsilon$} (qI2.315);
		
		\draw (qF3) .. controls +(8,10) and +(1,3) .. node[midway,above] {$\epsilon$} (qI1);
		\draw (qF1) ..  controls +(8,-10) and +(1,-3) .. node[midway,above] {$\epsilon$} (qI3);
	\end{tikzpicture}
	\caption{The automaton of the global type $L^*_N$.}
	\label{fig:lstar}
\end{figure}

In other words, $L^*$ is a Global Type whose language of executions
captures all possible combinations and exchanges of choices arising in a
generic instance of the RPCP problem.
This global type is constructed from the family of global types % TODO: forse cambiare in MSC
representing all tiles, and it forms the basis for proving the
non-realisability result.

Given the system of CFSMs $\projectionof{L^*}$ and the MSC  
$M_{\texttt{sol}}$, we need to show that  
$\executionsof{\projectionof{L^*}}{\synchmodel} \neq \executionsof{L^*}{\synchmodel}$.  
By construction of $L^*$, we have  
$M_{\texttt{sol}} \in \msclanguageof{\projectionof{L^*}}{\synchmodel}$.  
In contrast, $M_{\texttt{sol}} \notin  
\msclanguageof{L^*}{\synchmodel}$, since at least one tile differs.  
This demonstrates that there exists an execution that is valid for  
$\projectionof{L^*}$ but invalid for the Global Type $L^*$.  
Therefore, $L^*$ is \emph{not realisable}.  


\section{Undecidability proof}

Given the definitions and lemmas stated in the last section, we are now ready
to present the proof for the undecidability result.

\bigskip

\begin{theorem}\label{thm:main}
	Given a global type $G$, checking if $G$ is weakly-realisable is undecidable.
\end{theorem}

\begin{proof}
	The proof proceeds via a reduction from the RPCP problem.
	Given an instance $\{(v_1, w_1), \ldots, (v_m, w_m)\}$ of RPCP, we
	construct $L^*$ as specified in Definition~\ref{def:lstar}.
	
	We need to prove:
	\begin{center}
		$\Delta \in \text{RPCP}$ iff the global type $L^*$ is not weakly-realisable.
	\end{center}

	\begin{itemize}
		\item[$\Rightarrow$]
			Assume that
			$\Delta = (i_1, a_1, b_1, i_2, a_2, b_2, \ldots, i_m, a_m, b_m)$ are the indices
			for a solution to a generic RPCP problem instance, and the bits $a_j$ and
			$b_j$ indicate which string ($v_{i_j}$ or $w_{i_j}$) is chosen to go into
			the two (left and right) long strings. Assume also synchronous communication semantic.
			Consider the MSCs $M_x$ and $M_y$ obtained from the concatenation of
			$M_x = M^{a_1}_{i_1} \cdots M^{a_m}_{i_m}$ 
			and $M_y = M^{b_1}_{i_1} \cdots M^{b_m}_{i_m}$.
			The possible linearisations of both of these sequences of MSCs 
			must be included in the language of execution of $L^*$, by construction 
			of $L^*$ (Definition~\ref{def:lstar}). 
			This means that $M_x, M_y \in \msclanguageof{L^*}{\synchmodel}$.
			Additionally, $M_x,M_y\in \mscsetofmodel{\synchmodel}$
			because they are sequences of MSCs included in
			$\mscsetofmodel{\synchmodel}$ (Lemma~\ref{lemma:minsynch}).
			$M_x$ corresponds to the construction of the left side of the equivalence of the RPCP
			problem, and, instead, $M_y$ represents the construction of the right side.
			We then look at the projections $M_x|_{P1}$, $M_x|_{P2}$, $M_x|_{P3}$,
			and $M_x|_{P4}$ of $M_x$, and $M_y|_{P1}$, $M_y|_{P2}$, $M_y|_{P3}$, $M_y|_{P4}$ of $M_y$ onto the
			4 processes.
			Given that these are projection of MSCs included in $L^*$,
			they are possible execution of a CFSM $\cfsms$ that can execute $L^*$.
			Now consider the MSC $M_{\texttt{sol}}$ 
			formed from $M_y|_{P1}$, $M_y|_{P2}$, $M_x|_{P3}$, and $M_x|_{P4}$.
			This MSC represents the construction of the solution to
			the problem. Processes 1 and 2 construct the right part ($y_{i_1}...y_{i_m}$)
			and processes 3 and 4 construct the left part ($x_{i_1}...x_{i_m}$).
			%%% INIZIO PARTE IMPORTANTE
			The claim is that the combined MSC $M_{\texttt{sol}}$ is 
			made by $L^*$'s projections, therefore, it exists a CFSM $\cfsms$
			that $M_{\texttt{sol}} \in \mscsofcfsms{\cfsms}{\synchmodel}$,
			but the CFSM $\cfsms$ is not part of the language of execution of $L^*$ 
			$\executionsof{\cfsms}{\synchmodel} \neq \executionsof{L^*}{\synchmodel}$. 
			In other words, the language of the execution of $M_{\texttt{sol}}$ is included
			in the execution of the system, but it is not included in the execution of $L^*$. 
			By definition, the first thing to establish is that $M_{\texttt{sol}}$
			is indeed well-formed and synchronous MSC.
			The only new situation in terms of communication in $M_{\texttt{sol}}$ is the
			communication between $P_1$ and $P_4$, and between $P_2$ and $P_3$.
			But the communication between $P_1$ and $P_4$ is consistent in
			$M_y|_{P1}$ and $M_x|_{P4}$ (i.e., the sequence of messages sent from $P_1$ to
			$P_4$ in $M_y|_{P1}$ is equal to the sequence of messages received in $M_x|_{P4}$),
			and the communication between $P_2$ and $P_3$ is consistent in
			$M_y|_{P2}$ and $M_x|_{P3}$ because $R$ is a solution to the RPCP.
			Furthermore, the acyclicity of $M_{\texttt{sol}}$ follows from the property of the
			solution that the string formed by the first $j$ words on processes 1
			and 2 is always a prefix of the string formed by the first $j$ words
			on processes 3 and 4. Consequently, each message from $P_1$ to $P_4$
			is sent before it needs to be received. 
			Therefore, the MSC $M_{\texttt{sol}}$ is well-formed.

			We now prove that the MSC $M_{\texttt{sol}}$ is synchronous, that is
			$M_{\texttt{sol}} \in \mscsetofmodel{\synchmodel}$.
			Assume, by contradiction, that 
			$M_{\texttt{sol}} \notin \mscsetofmodel{\synchmodel}$.
			Then, there should be a cycle of dependencies in the communication pattern.
			There are no communication between $P_2$ and $P_4$, and between $P_1$
			and $P_3$. Therefore, this cycle must involve all processes, starting
			for example from $P_1$ and having this dependency graph
			$P_1\leftrightarrow P_2\leftrightarrow P_3\leftrightarrow P_4\leftrightarrow P_1$.
			The only new situation that can cause a cycle are the communication
			between $P_1$ and $P_4$, and between $P_2$ and $P_3$.
			We do not need to analyse the new communication between $P_1$ and $P_4$ because
			it is not feasible in any communication model, but we need to analyse the one
			between $P_2$ and $P_3$ because it's feasible in FIFO.

			% For the fist comunication, the only possible cycle pattern is depicted
			% in Fig.~\ref{fig:cycle1}

			% \begin{figure}[!ht]
			%  \centering
			%  \begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
			%   \declinst{P1}{P1}{}
			%   \declinst{P2}{P2}{}
			%   \declinst{P3}{P3}{}
			%   \declinst{P4}{P4}{}

			%   \mess[label position=above right,pos=0.45]{$i_z$}{P1}{P4}[8]
			%   \nextlevel
			%   \nextlevel
			%   \nextlevel
			%   \syncmscmess{($i_k,n_k)$}{P1}{P2}
			%   \mess[label position=above,pos=0.62]{$i_k$}{P1}{P4}
			%   \mess{}{P4}{P1}
			%   \nextlevel
			%   \syncmscmess{$(i_k,n_j)$}{P3}{P4}
			%   \nextlevel
			%   \nextlevel
			%   \mess{}{P4}{P1}[-8]
			%  \end{msc}
			%  \caption{The $M_i^n$ MSC.}
			%  \label{fig:cycle1}
			% \end{figure}

			% This cycle is not possible because it does not represent a
			% solution to the RPCP problem:
			% $x_1...x_{i_k}...x_{i_z}...x_m \neq y_1...y_{i_z}...y_{i_k}...y_m$.

			\begin{figure}[!ht]
				\centering
				\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
					\declinst{P1}{P1}{}
					\declinst{P2}{P2}{}
					\declinst{P3}{P3}{}
					\declinst{P4}{P4}{}

					\mess[label position=above right, pos=0.3]{$c$}{P2}{P3}[4]%
					\nextlevel
					\syncmscmess{$(i_k,n_k)$}{P1}{P2}
					\mess[pos=0.62]{$i_k$}{P1}{P4}%
					\mess{}{P4}{P1}
					\nextlevel
					\syncmscmess{$(i_k,n_j)$}{P3}{P4}
					\mess{}{P3}{P2}[-4]
				\end{msc}
				\caption{MSC communication that breaks synchrony.} % todo: modifica
				\label{fig:cycle2}
			\end{figure}

			For the communication between $P_2$ and $P_3$, the only possible cycle
			pattern is depicted in Figure~\ref{fig:cycle2} showed as an MSC.
			Suppose $P_2$ wants to send a character $c$, but $P_3$
			is not expecting any further characters. In order for
			$P_3$ to resume receiving, it must first receive an index
			from $P_4$. However, $P_4$ can only send this index
			after receiving it from $P_1$, which in turn must first
			communicate the index to $P_2$.
			At this point, $P_2$ needs to receive the index from
			$P_1$, but it cannot do so until it finishes sending
			character $c$. This creates a circular dependency among the
			processes, making the communication pattern impossible. % TODO: chiarire che non è come un caso di deadlock
			This cycle would break the prefix property as
			$x_1...x_{k-1}...x_m= y_1...y_{k-1}...y_m$, but the character $c$ appears
			in $y_1...y_{k-1}$ but not in $x_1...y_{k-1}$ contradicting the
			assumption that $y_1...y_{k-1} \leq x_1...x_{k-1}$.
			Therefore, we conclude that 
			$M_{\texttt{sol}} \in \mscsetofmodel{\synchmodel}$.

			We now prove the non-realisability of $L^*$, thanks to $M_{\texttt{sol}}$.
			Consider the system of CFSM $\projectionof{L^*}$ and a 
			linearisation $w_{\texttt{sol}}\in \linearisationsof{M_{\texttt{sol}}}{}$. 
			We need to prove that 	
			$\executionsof{\projectionof{L^*}}{\synchmodel}\neq\executionsof{L^*}{\synchmodel}$.
			Given that $M_{\texttt{sol}}$ is composed by projections of MSCs 
			used to build $L^*$, we can establish 
			$M_{\texttt{sol}}\in\msclanguageof{\projectionof{L^*}}{\synchmodel}$.
			Thanks to $M_{\texttt{sol}}$, we can notice that 
			$\executionsof{\projectionof{L^*}}{\synchmodel}$ cannot 
			itself be in $\executionsof{L^*}{\synchmodel}$ because there must be
			some index $i_j$ where $a_j \neq b_j$, and no execution of the Global 
			Type exists in $L^*$ where,
			after $P_1$ announces the index, what $P_2$ sends is not
			identical to what $P_3$ receives.
			$M_{\texttt{sol}}$ rapresents the possible execution 
			that establish the inequality. More formally, 
			$w_{\texttt{sol}} \in \executionsof{\projectionof{L^*}}{\synchmodel}$,
			but $w_{\texttt{sol}} \notin \executionsof{L^*}{\synchmodel}$. 
			This generally establish the
			non-realisability of $L^*$. Example~\ref{exm:teo} shows an instance
			of the construction of $M_{\texttt{sol}}$.

		\item[$\Leftarrow$]
			Suppose there is some MSC $M^@$ that can be built from possible 
			projections of $L^*$, but is not part of $L^*$'s language
			of executions. 
			More precisely, we want to derive a solution to $\Delta$ from $M^@$.
			First, it is clear that the projection $M^@|_{P1}$ consists of a sequence
			of pairs of messages (the first of each pair acknowledged), sent from
			process 1 to processes 2 and 4, respectively, with messages $(i, b)$ and $i$.
			Likewise, in order for process 2 to receive those messages,
			$M^@|_{P2}$ consists of a sequence of receipts of $(i, b)$ pairs, and after
			each $(i, b)$, either $v_i$ or $w_i$ is sent to process 3, based on whether
			$b = 0$ or $b = 1$, before the next index pair is received.
			Likewise, $M^@|_{P4}$ consists of a sequence of receipts of index $i$ from
			process 1, followed by sending of $(i, 0)$ or $(i, 1)$ to process 3, and
			$M^@|_{P3}$ consists of a sequence of receipt of $(i, 0)$ or $(i, 1)$ followed
			by receipt of $v_i$ or $w_i$, respectively.
			Now, since $M^@\notin \msclanguageof{L^*}{\synchmodel}$, for some index $i$ the choice of $v_i$ or
			$w_i$ must differ on process 2 and process 3. (Note, we are assuming that
			the buffers between processes are FIFO.)
			Furthermore, because of the precedences, the prefix formed by the first
			$j$ words on process 2 must precede the $(j + 1)$-th message from
			process 1 to process 4, which in turn precedes the $(j + 1)$-th message
			from 4 to 3, and hence the $(j + 1)$-th word on process 3. That is, the
			string formed by the first $j$ words on process 2 is a prefix of the string
			formed by the first $j$ words on process 3. Therefore, we can readily
			build a solution for $\Delta$ from $M^@$ by building the strings of the solution
			taking the projections of $P_1$ and $P_4$. In fact, $P_1$ builds 
			$y_{i_1}\cdots y_{i_m},$ and $P_4$ builds $x_{i_1}\cdots x_{i_m}$.

	\end{itemize}

\end{proof}

In this example, we will show the step-by-step construction 
of $M_{\texttt{sol}}$ from Theorem~\ref{thm:main}.

\bigskip

% TODO: dare un esempietto per far vedere che la prova regge
% Fatto... Andrà bene?
\begin{example}[$M_{\texttt{sol}}$ Example of Theorem~\ref{thm:main}]\label{exm:teo}
Consider the tiles and the solution of the RPCP instance 
in Example~\ref{exmp:rpcp}, with the tile set and the solution
with index sequence $(2,1,3)$
$$
 (v_1,w_1)=(\texttt{b},\texttt{bb}),\ 
 (v_2,w_2)=(\texttt{a},\texttt{ab}),\ 
 (v_3,w_3)=(\texttt{c},\texttt{c}).
$$
$$
 x_1=w_2,\ y_1=v_2;\quad x_2=v_1,\ y_2=w_1;\quad x_3=v_3,\ y_3=w_3
$$
This sequence is a solution because
$x_1x_2x_3=\texttt{ab}\,\texttt{b}\,\texttt{c}=\texttt{abbc}$ and
$y_1y_2y_3=\texttt{a}\,\texttt{bb}\,\texttt{c}=\texttt{abbc}$. The
prefix property and the ``some index differs'' condition are satisfied.

Therefore, the encoding of the solution is
$$\Delta = (i_1=2,a_1=1,b_1=0,i_2=1,a_2=0,b_2=1,i_3=3,a_3=0,b_3=1)$$

Recall that for each tile of index \(i\) we have two synchronous MSCs
\(M_i^0\) and \(M_i^1\) (see Definition~\ref{def:mni}), where the bit
indicates choosing \(v_i\) (0) or \(w_i\) (1) for the character comunication.
Using the concrete index sequence \((2,1,3)\) we form two
concatenated MSCs:
\[
  M_x\;=\; M^{1}_{2}\ \cdot\ M^{0}_{1}\ \cdot\ M^{0}_{3},
\qquad
  M_y\;=\; M^{0}_{2}\ \cdot\ M^{1}_{1}\ \cdot\ M^{1}_{3}.
\]
Here \(M_x\) encodes the \(\mathbf{x}\)-concatenation
\((x_1,x_2,x_3)=(w_2,v_1,v_3)\) (depicted 
in Figure~\ref{fig:exmp-mx}) and \(M_y\) encodes 
the \(\mathbf{y}\)-concatenation (depicted in 
Figure~\ref{fig:exmp-my}) \((y_1,y_2,y_3)=(v_2,w_1,w_3)\).

\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{P1}{}
	\declinst{P2}{P2}{}
	\declinst{P3}{P3}{}
	\declinst{P4}{P4}{}

	\syncmscmess{$(2,1)$}{P1}{P2}
	\syncmscmess{$2$}{P1}{P4}
	\syncmscmess{$(2,1)$}{P4}{P3}
	\syncmscmess{$a$}{P2}{P3}
	\syncmscmess{$b$}{P2}{P3}

	\syncmscmess{$(1,0)$}{P1}{P2}
	\syncmscmess{$1$}{P1}{P4}
	\syncmscmess{$(1,0)$}{P4}{P3}
	\syncmscmess{$b$}{P2}{P3}

	\syncmscmess{$(3,0)$}{P1}{P2}
	\syncmscmess{$3$}{P1}{P4}
	\syncmscmess{$(3,0)$}{P4}{P3}
	\syncmscmess{$c$}{P2}{P3}
\end{msc}
\caption{The MSC $M_x$.}
\label{fig:exmp-mx}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{P1}{}
	\declinst{P2}{P2}{}
	\declinst{P3}{P3}{}
	\declinst{P4}{P4}{}

	\syncmscmess{$(2,0)$}{P1}{P2}
	\syncmscmess{$2$}{P1}{P4}
	\syncmscmess{$(2,0)$}{P4}{P3}
	\syncmscmess{$a$}{P2}{P3}

	\syncmscmess{$(1,1)$}{P1}{P2}
	\syncmscmess{$1$}{P1}{P4}
	\syncmscmess{$(1,1)$}{P4}{P3}
	\syncmscmess{$b$}{P2}{P3}
	\syncmscmess{$b$}{P2}{P3}

	\syncmscmess{$(3,1)$}{P1}{P2}
	\syncmscmess{$3$}{P1}{P4}
	\syncmscmess{$(3,1)$}{P4}{P3}
	\syncmscmess{$c$}{P2}{P3}
\end{msc}
\caption{The MSC $M_y$.}
\label{fig:exmp-my}
\end{figure}

Recall that $M|_p$ denotes the projection of $M$ onto process $p$. 

We construct the MSC $M_{\texttt{sol}}$, using $M_x$ and $M_y$ projections, as follows:
$$
  M_{\texttt{sol}} = (M_y|_{P1},\; M_y|_{P2},\; M_x|_{P3},\; M_x|_{P4}),
$$
i.e.\ processes $1,2$ follow $M_y$ while $3,4$ follow $M_x$.
Intuitively, $M_{\texttt{sol}}$ pairs the right-side construction (from $M_y$)
with the left-side construction (from $M_x$). 
Figure~\ref{fig:exmp-msol} illustrates the behaviour of the MSC
$M_{\texttt{sol}}$. Observe that when process~3 expects to receive the
second character $\texttt{b}$ right after $a$, 
but process~2 cannot send it immediately:
it must first obtain the corresponding index and bit from process~1.
The prefix property guarantees
that every partial construction of the right-hand side is aligned with
a prefix of the left-hand side, therefore preserving synchronous
semantics throughout the execution.

From Figure~\ref{fig:exmp-msol}, it is evident that this kind of execution 
cannot occur in any execution of $L^*$, even though the MSC is constructed 
using valid projections included in its MSC language. 
More precisely, the language of $L^*$ contains only communications 
of the type represented by $M_x$ and $M_y$. 
The exchange involving the first $b$ character in Figure~\ref{fig:exmp-msol} 
does not belong to the execution language of $L^*$, but it belongs to
$L^*$'s projections. 
This particular communication pattern demonstrates 
the non-realisability of $L^*$.


\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{}{$M_y|_{P1}$}
	\declinst{P2}{}{$M_y|_{P2}$}
	\declinst{P3}{}{$M_x|_{P3}$}
	\declinst{P4}{}{$M_x|_{P4}$}

	\syncmscmess{$(2,1)$}{P1}{P2}
	\syncmscmess{$2$}{P1}{P4}
	\syncmscmess{$(2,0)$}{P4}{P3}
	\syncmscmess{$a$}{P2}{P3}
	\mess{}{P3}{P2}[4]
	\nextlevel

	\syncmscmess{$(1,0)$}{P1}{P2}
	\mess[pos=0.4]{$1$}{P1}{P4}
	\mess{}{P4}{P1}
	\nextlevel
	\syncmscmess{$(1,1)$}{P4}{P3}
	\mess[pos=0.2]{$b$}{P2}{P3}[-4]
	\nextlevel
	\syncmscmess{$b$}{P2}{P3}
	
	\syncmscmess{$(3,0)$}{P1}{P2}
	\syncmscmess{$3$}{P1}{P4}
	\syncmscmess{$(3,1)$}{P4}{P3}
	\syncmscmess{$c$}{P2}{P3}
\end{msc}
\caption{The MSC $M_\texttt{sol}$.}
\label{fig:exmp-msol}
\end{figure}

\end{example}

The sequence of lemmas and the main theorem collectively establish the
undecidability of weak-realisability for global types. Having developed the
theoretical foundation, we now move to the next section, where we focus on the
practical aspects of analysing realisability, and introduce the \textsc{ReSCu} tool.