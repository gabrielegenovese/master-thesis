\chapter{Weak-Realisability is Undecidable for Synch Global Types}\label{sec:proof}

As already mentioned, the first contribution is Theorem~\ref{thm:main},
which states that \emph{Weak-realisability is undecidable for 
synchronous global types}. 
To understand this result, I have already covered the basic notions in 
Chapter~\ref{sec:pre} on MSCs, Global Types, and Weak-realisability. 
These concepts are general and align 
closely with definitions used in previously established works. 
We now introduce the main objects employed in the proof of Theorem~\ref{thm:main}. 
The proof itself is adapted from the work of 
Alur et~al.~\cite{alur2005realizability}. 
In between the new definition's declaration, I will also highlight the 
differences with the original proof.

\section{Definitions}
The proof is carried out by a \emph{reduction} from the
\textbf{Relaxed Post Correspondence Problem (RPCP)}, a variant of
the classical Post Correspondence Problem (PCP). 
RPCP was shown to be undecidable by
Alur~et~al.~\cite{alur2005realizability}, via reduction from PCP.
The main idea is to encode the existence of a
solution to an RPCP instance into the (non-)realisability of our formal
specification. In the original proof, they use MSCs, therefore, 
defining an HMSC called $M^*$. In my case, I will define a
\emph{global type} (called $L^*$) built from synchronous global types.
Therefore, we need to prove:
$$
\Delta \in \text{RPCP} \quad\iff\quad L^* \text{ is not realisable}.
$$
In the original proof, $L^*$ is not a global type, but an MSC.
Then, we need to change some base definitions of the original paper
to fit the model. 

\bigskip

\begin{definition}[Relaxed Post Correspondence Problem]
	Given a set of tiles $\{(v_1, w_1), (v_2, w_2), ..., (v_r, w_r)\}$, 
	determine whether there exist indices $i_1, ..., i_m$ such that
	$$x_{i_1}\cdots x_{i_m} = y_{i_1}\cdots y_{i_m},$$
	where $x_{i_j}, y_{i_j} \in \{v_{i_j}, w_{i_j}\}$, such that:
	\begin{itemize}
		\item there exists at least one index $i_\ell$ for which $x_{i_\ell}\neq y_{i_\ell}$, and
		\item for all $j \leq m$, $y_{i_1}\cdots y_{i_j}$ is a prefix of $x_{i_1}\cdots x_{i_j}$.
	\end{itemize}
\end{definition}

Intuitively, RPCP requires that the concatenation on the left-hand side always 
grows at least as fast as the right-hand side, while ensuring that at least one 
chosen tile differs between the two sequences. Moreover, in constructing the 
strings, we may freely choose which element of each tile (either $v_i$ or $w_i$) 
contributes to the left or right sequence.

\bigskip

\begin{example}[Simple RPCP instance]\label{exmp:rpcp}
Consider the tile set
\[
(v_1,w_1)=(\texttt{b},\ \texttt{bb}),\quad
(v_2,w_2)=(\texttt{a},\ \texttt{ab}),\quad
(v_3,w_3)=(\texttt{c},\ \texttt{c}).
\]
Take the index sequence $(2,1,3)$ and the choices
\[
x_1 = w_2,\ y_1 = v_2;\quad
x_2 = v_1,\ y_2 = w_1;\quad
x_3 = v_3,\ y_3 = w_3.
\]
Then
\[
x_1 x_2 x_3 = \texttt{ab}\ \texttt{b}\ \texttt{c} = \texttt{abbc},
\qquad
y_1 y_2 y_3 = \texttt{a}\ \texttt{bb}\ \texttt{c} = \texttt{abbc},
\]
so the two sides are equal.

We now check the RPCP conditions:
\begin{itemize}
  \item \textbf{at least one mismatch:} here $x_1\neq y_1$ and
        $x_2\neq y_2$, so the ``some index differs'' condition holds;
  \item \textbf{prefix property:} for every prefix length $j$ we have
        $y_{1}\cdots y_{j}$ is a prefix of $x_{1}\cdots x_{j}$:
        \begin{itemize}
          \item $j=1$: $y_1=\texttt{a}$ is a prefix of $x_1=\texttt{ab}$;
          \item $j=2$: $y_1y_2=\texttt{abb}$ is a prefix of $x_1x_2=\texttt{abb}$;
          \item $j=3$: $y_1y_2y_3=\texttt{abbc}$ is a prefix of $x_1x_2x_3=\texttt{abbc}$.
        \end{itemize}
\end{itemize}
\end{example}

\bigskip

We have now identified the main problem to which our proof reduces.  
The next step is to encode an RPCP instance into our formal model.
In the original proof, they use MSCs, but in my case I need to give
an encoding using Global Types. I will give both definition in order
to give a cleaner parallel.

\bigskip

\begin{definition}[$M^n_i$]\label{def:mni}
	Given the index $i$ of a tile $(v_i, w_i)$, and
	given an interger $n\in\{0,1\}$, where:
	\begin{itemize}
		\item if $n=0$, then $x_i=v_i$;
		\item if $n=1$, then $x_i=w_i$;
	\end{itemize}
	let's define the behavior of the MSC $M^n_i$.
	Firstly, Process~1 synchronously sends the message
	$m_1 = (i, n)$ to Process~2, then Process~1 transmits the index $m_2=i$
	to Process~4. Subsequently, Process~4 sends $m_3 = (i, n)$
	synchronously to Process~3. After these control messages, Process~2
	sends the characters $m_i^1 = x_i^1,..., m_i^c = x_i^c$
	synchronously to Process~3 (where $c$ is the length of $x_i$).
	This MSC is depicted in Figure~\ref{fig:mni}, 

	\begin{figure}[!ht]
		\centering
		\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
			\declinst{P1}{P1}{}
			\declinst{P2}{P2}{}
			\declinst{P3}{P3}{}
			\declinst{P4}{P4}{}

			\syncmscmess{$(i,n)$}{P1}{P2}
			\syncmscmess{$i$}{P1}{P4}
			\syncmscmess{$(i,n)$}{P4}{P3}
			\syncmscmess{$x_i^1$}{P2}{P3}
			\syncmscmess{...}{P2}{P3}
			\syncmscmess{$x_i^c$}{P2}{P3}
		\end{msc}
		\caption{The $M_i^n$ MSC.}
		\label{fig:mni}
	\end{figure}

\end{definition}

Given a RPCP instance $\{(v_1,w_1),\ldots,(v_m,w_m)\}$, we associate  
with each pair $(v_i,w_i)$ two MSCs $M^0_i$ and $M^1_i$, following  
Definition~\ref{def:mni}. Each MSC $M^n_i$ is \emph{synchronous}  
(Lemma~\ref{lemma:minsynch}). Intuitively, the MSC $M_i^n$ encodes the  
construction of a string given some tiles through the interaction of four processes.  
Processes~2 and~3 are responsible for building the string itself,  
while Processes~1 and~4 transmit the index information to Processes~2  
and~3, respectively. In particular, Process~1 initiates the choice and  
forwards it to Process~4.

\bigskip

\begin{lemma}\label{lemma:minsynch}
	The MSC $M_i^n$ belongs to $\mscsetofmodel{\synchmodel}$.
\end{lemma}

\begin{proof}
	By Definition~\ref{def:linearisable-msc} and
	Definition~\ref{def:synchronous},
	we need to show a linearization with all send operations
	followed by their corresponding receive operations:
	$$
	\{~!m_1?m_1\ !m_2?m_2\ !m_3?m_3\ !m_i^1?m_i^1 \ldots !m_i^c?m_i^c~\}.
	$$
	Such a linearization exists by construction, hence $M_i^n$ is synchronous.
\end{proof}

We now give the same definition of the encoding, but in a Global Type format.

\bigskip

\begin{definition}[$G_i^n$]\label{def:gni}
	Given a tile $(v_i,w_i)$ and a bit $n\in\{0,1\}$, define
    $x_i = v_i$ if $n=0$, and $x_i = w_i$ if $n=1$. The global
    type $G_i^n$ is composed of:
    \begin{itemize}
        \item $\mathbb{P}=\{p,q,r,s\}$;
        \item $\mathbb{M}=\{m_1,m_2,m_3,m_{x_i^1},\ldots,m_{x_i^c}\}$,
              where $m_1=(i,n),\ m_2=i,\ m_3=(i,n),$ and
              $m_{x_i^j}=x_i^j$ for $1\leq j\leq c$, with
              $c=|x_i|$;
        \item Arr $=\{$\arrmess{p}{q}{m_1}, \arrmess{p}{s}{m_2},
              \arrmess{s}{r}{m_3}, \arrmess{q}{r}{m_{x_i^1}}, $\ldots$,
              \arrmess{q}{r}{m_{x_i^c}}$\}$, where each arrow denotes
              a synchronous message with acknowledgment.
    \end{itemize}
    The automaton of $G_i^n$ is shown in Figure~\ref{fig:gtype}.
	
	\begin{figure}[!ht]
		\centering
		\begin{tikzpicture}[->, node distance=35mm, on grid, auto]
			\node[state] (q0) {$q_0$};
			\node[state] (q1) [right=of q0] {$q_1$};
			\node[state] (q2) [right=of q1] {$q_2$};
			\node[state] (q3) [below left=of q0] {$q_3$};
			\node[state] (q4) [right=of q3] {$q_4$};
			\node[state] (q5) [right=of q4] {$\cdots$};
			\node[state,accepting] (q6) [right=of q5] {$q_x$};

			\path (q0) edge[] node[above] {\arrmess{p}{q}{(i,n)}} (q1);
			\path (q1) edge[] node[above] {\arrmess{p}{s}{i}} (q2);
			\path (q2) edge[] node[above left] {\arrmess{s}{r}{(i,n)}} (q3.60);
			\path (q3) edge[] node[above] {\arrmess{q}{r}{S_1}} (q4);
			\path (q4) edge[] node[above] {\arrmess{q}{r}{...}} (q5);
			\path (q5) edge[] node[above] {\arrmess{q}{r}{S_c}} (q6);
		\end{tikzpicture}
		\caption{The global type $G_i^n$.}
		\label{fig:gtype}
	\end{figure}

\end{definition}

Intuitively, $G_i^n$ specifies the same communication pattern as the MSC  
$M^n_i$ introduced in Definition~\ref{def:mni}. This structural  
correspondence will be made precise in the next lemma (Lemma~\ref{lmm:msgs}).  

Before establishing the connection between MSCs and Global Types,
we briefly summarize the rationale behind the design of $M_i^n$ and $G_i^n$.

Suppose that $\Delta=(i_1,a_1,b_1,\ldots,i_m,a_m,b_m)$ is a  
solution to the RPCP instance. From this solution we construct two MSC  
sequences:
\[
G_x = G^{a_1}_{i_1}\cdots G^{a_m}_{i_m}, \qquad  
G_y = G^{b_1}_{i_1}\cdots G^{b_m}_{i_m}.
\]
Both $G_x$ and $G_y$ are synchronous concatenations of synchronous  
MSCs. We then define a third MSC $G_{\texttt{sol}}$, obtained by  
projecting $G_y$ onto processes $P1,P2$ and $G_x$ onto processes  
$P3,P4$. Intuitively, processes $P1,P2$ represent the construction of  
the \emph{right-hand string} $y_{i_1}\cdots y_{i_m}$, while processes  
$P3,P4$ represent the construction of the \emph{left-hand string}  
$x_{i_1}\cdots x_{i_m}$. The prefix property of RPCP guarantees that  
$G_{\texttt{sol}}$ is acyclic and \emph{synchronous}. Establishing the  
synchrony of $G_{\texttt{sol}}$ is non-trivial, and this step is an  
addition to the original proof. By construction, $L^*$ weakly implies  
$G_{\texttt{sol}}$, but $G_{\texttt{sol}} \notin L^*$, since at least  
one tile differs. Consequently, $L^*$ is \emph{not realisable}.
  
With these constructions in place, we proceed to introduce the main  
objects used in the proof. Specifically, we first show how a Global  
Type can represent a single \verb|synch| MSC.

\bigskip

% TODO: ivan: forse lemma?
\begin{definition}[$G_M$]\label{def:gm}
	Given an MSC $M\in \mscsetofmodel{\synchmodel}$, there exists a
	global type $G_M$ such that $M \in \existentialmsclanguageof{\gt}$.
\end{definition}

Definition~\ref{def:gm} establishes a direct correspondence between a  
single synchronous MSC and a global type. In particular, every  
synchronous MSC can be captured precisely by a global type whose  
language contains that MSC. This correspondence will be useful  
when embedding RPCP instances into the global type framework.
We now introduce a more structured global type, parameterized by a  
string $S$, which will serve as the building block in the reduction.

\bigskip

% TODO: check
\begin{lemma}\label{lmm:msgs}
The MSC $M^n_i$ (Definition~\ref{def:mni}) is included in 
$\languageof{G_S}{}{}$ (Definition~\ref{def:gni}).
\end{lemma}

% TODO: Da rifare meglio, non ha senso quel L(M) = L(G)
\begin{proof}
	Assume $i,n$ are integers.
	Both $M^n_i$ and $G_i^n$ describe the same communication structure:
	process $p$ sends $(i,n)$ to $q$ and $i$ to $s$;
	process $s$ relays $(i,n)$ to $r$;
	process $q$ then sends the characters of $x_i$ to $r$.
	The sequence of messages is identical in both 
	$M^n_i$ and $G_i^n$. Since both models enforce synchronous communication, 
	their linearisations coincide. Hence, $L(M^n_i) = L(G_S)$.
\end{proof}

Having established the correspondence between an individual MSC and a  
global type, we can now extend Definition~\ref{def:gm} to encompass  
sets of MSCs, thereby capturing entire families of synchronous  
behaviours within a global type. This definition is used to easily 
construct the global type $L^*$.

\bigskip

% TODO DOMANDA: inutile? da rifare usando gni
\begin{definition}[$G^*$]\label{def:gstar}
	Given a set of MSCs $\mathcal{M} =\{M\ |\ M\in\mscsetofmodel{\synchmodel}\}$,
	$G^*$ is the set of global types such that $G^*=\{G_M\ |\ M \in \setmsc\}$,
	where $G_M$ is built using Definition~\ref{def:gm}.
\end{definition}

Informally, for every MSC $M\in\setmsc$ there exists a global type $G\in G^*$ that
captures the language of $M$. Now, let's build the automaton that represents
all the possible combinations and constructions of a set of MSCs.

\bigskip

% TODO DOMANDA: inutile? da rifare usando gni
\begin{definition}[The $L^*$ global type]\label{def:lstar}
	Assume a finite set $\setmsc$ of MSCs, where
	$\setmsc = \{M\ |\ M \in \mscsetofmodel{\synchmodel}\}$. Let $G^*$
	be defined as in Definition~\ref{def:gstar}.
	We define the global type $L^*_{N}$ as the automaton
	$\mathcal A = (Q,\Sigma, \delta, l_0, F)$ where:
	\begin{itemize}
		\item $Q = \{v_I,v_T\}\cup \bigcup_{G\in G^*} Q^G$;
		\item $\Sigma = \{\epsilon\}\cup\bigcup_{G\in G^*} \Sigma^G$;
		\item $\delta: Q \times \Sigma \rightarrow 2^Q$ is defined by:
			      \begin{enumerate}
				       \item $\forall G \in G^*,\ \delta(v_I, \varepsilon) = q_0^G$ where $q_0^G$ is the initial state of $G$,
				       \item $\forall G \in G^*,\ \forall q_f^G \in F^G,\ \delta(q_f^G, \varepsilon) = v_T$,
				       \item $\forall G, G' \in G^*,\ \forall q_f^G \in F^G,\ \delta(q_f^G, \varepsilon) = q_0^{G'}$.
			      \end{enumerate}
		\item $l_0 = v_I$ is the initial state;
		\item $F = v_T$ is the accepting state.
	\end{itemize}
	The automaton of $L^*_{N}$ is shown in Figure~\ref{fig:lstar}.  
	Finally, $L^*$ is obtained as the determinisation of $L^*_{N}$.
\end{definition}

\begin{figure}[!ht]
	\centering
	\begin{tikzpicture}[->, node distance=35mm, on grid, auto]
		\node[state] (vI) {$v_I$};
		\node[state] (qI2) [right=of vI] {$\cdots$};
		\node[state] (qI1) [above=of qI2] {$q_0^{G^1}$};
		\node[state] (qI3) [below=of qI2] {$q_0^{G^n}$};
		\node[state] (qM1) [right=of qI1] {$\cdots$};
		\node[state] (qM2) [right=of qI2] {$\cdots$};
		\node[state] (qM3) [right=of qI3] {$\cdots$};
		\node[state] (qF1) [right=of qM1] {$q_f^{G^1}$};
		\node[state] (qF2) [right=of qM2] {$\cdots$};
		\node[state] (qF3) [right=of qM3] {$q_f^{G^n}$};
		\node[state,accepting] (vT) [right=of qF2] {$v_T$};

		\path (vI) edge[] node[above] {$\epsilon$} (qI1);
		\path (vI) edge[] node[above] {$\epsilon$} (qI2);
		\path (vI) edge[] node[above] {$\epsilon$} (qI3);
		\path (qI1) edge[] node[above] {\arrmess{p}{q}{(i^{G^1},n^{G^1})}} (qM1);
		\path (qI2) edge[] node[above] {} (qM2);
		\path (qI3) edge[] node[above] {\arrmess{p}{q}{(i^{G^n},n^{G^n})}} (qM3);
		\path (qM1) edge[] node[above] {\arrmess{q}{r}{S^{G^1}_c}} (qF1);
		\path (qM2) edge[] node[above] {} (qF2);
		\path (qM3) edge[] node[above] {\arrmess{q}{r}{S^{G^n}_c}} (qF3);
		\path (qF1) edge[] node[above] {$\epsilon$} (vT);
		\path (qF2) edge[] node[above] {$\epsilon$} (vT);
		\path (qF3) edge[] node[above] {$\epsilon$} (vT);
		
		\draw (qF1.135) to [bend right=30] node[above] {$\epsilon$} (qI1.45);
		\draw (qF2.135) to [bend right=30] node[above] {$\epsilon$} (qI2.45);
		\draw (qF3.135) to [bend right=30] node[above] {$\epsilon$} (qI3.45);

		\draw (qF1.225) to node[above] {$\epsilon$} (qI2.60);
		\draw (qF3.120) to node[above] {$\epsilon$} (qI2.315);
		
		\draw (qF3) .. controls +(8,10) and +(1,3) .. node[midway,above] {$\epsilon$} (qI1);
		\draw (qF1) ..  controls +(8,-10) and +(1,-3) .. node[midway,above] {$\epsilon$} (qI3);
	\end{tikzpicture}
	\caption{The automaton of the global type $L^*_N$.}
	\label{fig:lstar}
\end{figure}

Informally, $L^*$ denotes the set of all possible executions  
arising from a family of MSCs. This construction constitutes the  
final component required for the proof, as it provides the key  
structure used to demonstrate non-realisability.

\section{Undecidability proof}

Given the definitions and lemmas state in the last section, I am now ready
to present the proof for the undecidability result.

\bigskip

\begin{theorem}\label{thm:main}
	Given a global type $G$, checking if $G$ is weakly-realisable is undecidable.
\end{theorem}

\begin{proof}
	The proof proceeds via a reduction from the RPCP problem. Let's define some useful
	elements for the proof.

	Given an instance $\Delta = \{(v_1, w_1), \ldots, (v_m, w_m)\}$ of RPCP, we
	construct a set $L$ of MSCs over four processes as follows. For each pair
	$(v_i, w_i)$, we define two MSCs, $M^0_i$ and $M^1_i$, as illustrated in
	Figure~\ref{fig:mni}.
	Observe that the communication graph of each MSC is strongly connected and
	involves all four processes. Therefore, the MSC represented from
	$L^*$ and derived from $L$ is bounded.
	With the set $L$, and following the Definition~\ref{def:lstar},
	we can construct the global type $L^*$.

	We need to prove:
	\begin{center}
		$\Delta \in \text{RPCP}$ iff the global type $L^*$ is not weakly-realisable.
	\end{center}

	\begin{itemize}
		\item[$\Rightarrow$]
		      Let's assume that
		      $\Delta = (i_1, a_1, b_1, i_2, a_2, b_2, \ldots, i_m, a_m, b_m)$ are the indices
		      for a solution to a generic RPCP problem instance, and the bits $a_j$ and
		      $b_j$ indicate which string ($v_{i_j}$ or $w_{i_j}$) is chosen to go into
		      the two (left and right) long strings. Let's also assume synchronous communication.
			  Consider the new Global Types $G_x$ and $G_y$ obtained from the concatenation of
		      $G_x = G^{a_1}_{i_1} \cdots G^{a_m}_{i_m}$ 
			  and $G_y = G^{b_1}_{i_1} \cdots G^{b_m}_{i_m}$.
		      The language of the executions of both of these (sequences of) Global Types 
			  must be included in the language of execution of $L^*$. 
			  Additionally, the language of MSCs of these Global Types are 
			  in $\mscsetofmodel{\synchmodel}$ because they are sequence of 
			  $\mscsetofmodel{\synchmodel}$ MSC (Lemma~\ref{lemma:minsynch}).
		      $G_x$ corresponds to the construction of the left side of the equivalence of the RPCP
		      problem, and, instead, $G_y$ represents the construction of the right side.
		      We then look at the projections $G_x|_{P1}$, $G_x|_{P2}$, $G_x|_{P3}$,
		      and $G_x|_{P4}$ of $G_x$, and $G_y|_{P1}$, $G_y|_{P2}$, $G_y|_{P3}$, $G_y|_{P4}$ of $G_y$ onto the
		      4 processes. Now consider a Global Type $G_{\texttt{sol}}$ 
			  formed from $G_y|_{P1}$, $G_y|_{P2}$, $G_x|_{P3}$, and $G_x|_{P4}$.
		      This Global Type represents the construction of the solution to
		      the problem. Processes 1 and 2 construct the right part ($y_{i_1}...y_{i_m}$)
		      and processes 3 and 4 construct the left part ($x_{i_1}...x_{i_m}$).
		      The claim is that the combined Global Type $G_{\texttt{sol}}$ is 
		      implied by $L^*$, but it is not part of its language. 
			  In other words, the language of the execution of $G_{\texttt{sol}}$ is included
			  in the execution of the system, but it is not included in the execution of $L^*$. 
			  By definition, the only thing to establish is that $G_{\texttt{sol}}$
		      is indeed a Global Type, in the sense that it is well-formed,
		      and synchronous.
		      The only new situation in terms of communication in $G_{\texttt{sol}}$ is the
		      communication between $P_1$ and $P_4$, and between $P_2$ and $P_3$.
		      But the communication between $P_1$ and $P_4$ is consistent in
		      $G_y|_{P1}$ and $G_x|_{P4}$ (i.e., the sequence of messages sent from $P_1$ to
		      $P_4$ in $G_y|_{P1}$ is equal to the sequence of messages received in $G_x|_{P4}$),
		      and the communication between $P_2$ and $P_3$ is consistent in
		      $G_y|_{P2}$ and $G_x|_{P3}$ because $R$ is a solution to the RPCP.
		      Furthermore, the acyclicity of $G_{\texttt{sol}}$ follows from the property of the
		      solution that the string formed by the first $j$ words on processes 1
		      and 2 is always a prefix of the string formed by the first $j$ words
		      on processes 3 and 4. Consequently, each message from $P_1$ to $P_4$
		      is sent before it needs to be received.

		      Finally, we prove that 
			  $\msclanguageof{G_{\texttt{sol}}}{\synchmodel} \in \mscsetofmodel{\synchmodel}$.
		      Assume, for contradiction, that 
			  $\msclanguageof{G_{\texttt{sol}}}{\synchmodel} \notin \mscsetofmodel{\synchmodel}$.
		      Then, there should be a cycle of dependencies in the communication pattern.
		      There are no communication between $P_2$ and $P_4$, and between $P_1$
		      and $P_3$. Therefore, this cycle must involve all processes, starting
		      for example from $P_1$ and having this dependency graph
		      $P_1\leftrightarrow P_2\leftrightarrow P_3\leftrightarrow P_4\leftrightarrow P_1$.
		      The only new situation that we now that can cause a cycle are the communication
		      between $P_1$ and $P_4$, and between $P_2$ and $P_3$.
		      We don't need to analyse the new communication between $P_1$ and $P_4$ because
		      it's not feasible in any communication model, but we need to analyse the one
		      between $P_2$ and $P_3$ because it's feasible in FIFO.

		      % For the fist comunication, the only possible cycle pattern is depicted
		      % in Fig.~\ref{fig:cycle1}

		      % \begin{figure}[!ht]
		      %  \centering
		      %  \begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
		      %   \declinst{P1}{P1}{}
		      %   \declinst{P2}{P2}{}
		      %   \declinst{P3}{P3}{}
		      %   \declinst{P4}{P4}{}

		      %   \mess[label position=above right,pos=0.45]{$i_z$}{P1}{P4}[8]
		      %   \nextlevel
		      %   \nextlevel
		      %   \nextlevel
		      %   \syncmscmess{($i_k,n_k)$}{P1}{P2}
		      %   \mess[label position=above,pos=0.62]{$i_k$}{P1}{P4}
		      %   \mess{}{P4}{P1}
		      %   \nextlevel
		      %   \syncmscmess{$(i_k,n_j)$}{P3}{P4}
		      %   \nextlevel
		      %   \nextlevel
		      %   \mess{}{P4}{P1}[-8]
		      %  \end{msc}
		      %  \caption{The $M_i^n$ MSC.}
		      %  \label{fig:cycle1}
		      % \end{figure}

		      % This cycle is not possible because it does not represent a
		      % solution to the RPCP problem:
		      % $x_1...x_{i_k}...x_{i_z}...x_m \neq y_1...y_{i_z}...y_{i_k}...y_m$.

		      \begin{figure}[!ht]
			      \centering
			      \begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
				      \declinst{P1}{P1}{}
				      \declinst{P2}{P2}{}
				      \declinst{P3}{P3}{}
				      \declinst{P4}{P4}{}

				      \mess[label position=above right, pos=0.3]{$c$}{P2}{P3}[4]%
				      \nextlevel
				      \syncmscmess{$(i_k,n_k)$}{P1}{P2}
				      \mess[pos=0.62]{$i_k$}{P1}{P4}%
				      \mess{}{P4}{P1}
				      \nextlevel
				      \syncmscmess{$(i_k,n_j)$}{P3}{P4}
				      \mess{}{P3}{P2}[-4]
			      \end{msc}
			      \caption{MSC communication that breaks synchrony.} % todo: modifica
			      \label{fig:cycle2}
		      \end{figure}

		      For the communication between $P_2$ and $P_3$, the only possible cycle
		      pattern is depicted in Figure~\ref{fig:cycle2} showed as an MSC.
		      Suppose $P_2$ wants to send a character $c$, but $P_3$
		      is not expecting any further characters. In order for
		      $P_3$ to resume receiving, it must first receive an index
		      from $P_4$. However, $P_4$ can only send this index
		      after receiving it from $P_1$, which in turn must first
		      communicate the index to $P_2$.
		      At this point, $P_2$ needs to receive the index from
		      $P_1$, but it cannot do so until it finishes sending
		      character $c$. This creates a circular dependency among the
		      processes, making the communication pattern impossible. % TODO: chiarire che non è come un caso di deadlock
		      This cycle would break the prefix property as
		      $x_1...x_{k-1}...x_m= y_1...y_{k-1}...y_m$, but the character $c$ appears
		      in $y_1...y_{k-1}$ but not in $x_1...y_{k-1}$ contradicting the
		      assumption that $y_1...y_{k-1} \leq x_1...x_{k-1}$.
		      Therefore, we conclude that 
			  $\msclanguageof{G_{\texttt{sol}}}{\synchmodel} \in \mscsetofmodel{\synchmodel}$.

			  Assume that the system of CFMS $\cfsms_G$ is the system of $G_{\texttt{sol}}$.
			  We need to prove that 	
			  $\executionsof{\cfsms_G}{\synchmodel} \neq \executionsof{L^*}{\synchmodel}$.
		      Note that $\executionsof{\cfsms_G}{\synchmodel}$ cannot 
			  itself be in $\executionsof{L^*}{\synchmodel}$ because there must be
		      some index $i_j$ where $a_j \neq b_j$, and no execution of the Global 
			  Type exists in $L^*$ where,
		      after $P_1$ announces the index, what $P_2$ sends is not
		      identical to what $P_3$ receives.

		\item[$\Leftarrow$]
		      Suppose there is some Global Type $G^@$ which
		      exists in any realisation of $L^*$, but is not in $L^*$ itself. We want
		      to derive a solution to $\Delta$ from $G^@$.
		      First, it is clear that the projection $G^@|_{P1}$ must consist of a sequence
		      of pairs of messages (the first of each pair acknowledged), sent from
		      process 1 to processes 2 and 4, respectively, with messages $(i, b)$ and $i$.
		      Likewise, it is clear that, in order for process 2 to receive those messages,
		      $G^@|_{P2}$ must consist of a sequence of receipts of $(i, b)$ pairs, and after
		      each $(i, b)$, either $v_i$ or $w_i$ is sent to process 3, based on whether
		      $b = 0$ or $b = 1$, before the next index pair is received.
		      Likewise, $G^@|_{P4}$ consists of a sequence of receipts of index $i$ from
		      process 1, followed by sending of $(i, 0)$ or $(i, 1)$ to process 3, and
		      $G^@|_{P3}$ consists of a sequence of receipt of $(i, 0)$ or $(i, 1)$ followed
		      by receipt of $v_i$ or $w_i$, respectively.
		      Now, since $G^@$ is not in $L^*$, for some index $i$ the choice of $v_i$ or
		      $w_i$ must differ on process 2 and process 3. (Note, we are assuming that
		      the buffers between processes are FIFO.)
		      Furthermore, because of the precedences, the prefix formed by the first
		      $j$ words on process 2 must precede the $(j + 1)$-th message from
		      process 1 to process 4, which in turn precedes the $(j + 1)$-th message
		      from 4 to 3, and hence the $(j + 1)$-th word on process 3. That is, the
		      string formed by the first $j$ words on process 2 is a prefix of the string
		      formed by the first $j$ words on process 3. Therefore, we can readily
		      build a solution for $\Delta$ from $G^@$ by building the strings of the solution
		      taking the projections of $P_1$ and $P_4$. In fact, $P_1$ builds 
			  $y_{i_1}\cdots y_{i_m},$ and $P_4$ builds $x_{i_1}\cdots x_{i_m}$.

	\end{itemize}

\end{proof}

In this example, I will show the step-by-step construction 
of $M_{\texttt{sol}}$ from Theorem~\ref{thm:main}.

\bigskip

% TODO: dare un esempietto per far vedere che la prova regge
% Fatto... Andrà bene?
\begin{example}[$G_{\texttt{sol}}$ Example of Theorem~\ref{thm:main}]
Consider the tiles and the solution of the RPCP instance 
in Example~\ref{exmp:rpcp}, with the tile set and the solution
with index sequence $(2,1,3)$
$$
 (v_1,w_1)=(\texttt{b},\texttt{bb}),\ 
 (v_2,w_2)=(\texttt{a},\texttt{ab}),\ 
 (v_3,w_3)=(\texttt{c},\texttt{c}).
$$
$$
 x_1=w_2,\ y_1=v_2;\quad x_2=v_1,\ y_2=w_1;\quad x_3=v_3,\ y_3=w_3
$$
This sequence is a solution because
$x_1x_2x_3=\texttt{ab}\,\texttt{b}\,\texttt{c}=\texttt{abbc}$ and
$y_1y_2y_3=\texttt{a}\,\texttt{bb}\,\texttt{c}=\texttt{abbc}$. The
prefix property and the ``some index differs'' condition are satisfied.

Therefore, the encoding of the solution is
$$\Delta = (i_1=2,a_1=1,b_1=0,i_2=1,a_2=0,b_2=1,i_3=3,a_3=0,b_3=1)$$

Recall that for each tile index \(i\) we have two synchronous MSCs
\(G_i^0\) and \(G_i^1\) (see Definition~\ref{def:gni}), where the bit
indicates choosing \(v_i\) (0) or \(w_i\) (1) for the character stream.
Using the concrete index sequence \((2,1,3)\) we form two
concatenated MSCs:
\[
  G_x\;=\; G^{1}_{2}\ \cdot\ G^{0}_{1}\ \cdot\ G^{0}_{3},
\qquad
  G_y\;=\; G^{0}_{2}\ \cdot\ G^{1}_{1}\ \cdot\ G^{1}_{3}.
\]
Here \(G_x\) encodes the \(\mathbf{x}\)-concatenation
\((x_1,x_2,x_3)=(w_2,v_1,v_3)\) (depicted 
in Figure~\ref{fig:exmp-mx}) and \(G_y\) encodes 
the \(\mathbf{y}\)-concatenation (depicted in 
Figure~\ref{fig:exmp-my}) \((y_1,y_2,y_3)=(v_2,w_1,w_3)\).

\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{P1}{}
	\declinst{P2}{P2}{}
	\declinst{P3}{P3}{}
	\declinst{P4}{P4}{}

	\syncmscmess{$(2,1)$}{P1}{P2}
	\syncmscmess{$2$}{P1}{P4}
	\syncmscmess{$(2,1)$}{P4}{P3}
	\syncmscmess{$a$}{P2}{P3}
	\syncmscmess{$b$}{P2}{P3}

	\syncmscmess{$(1,0)$}{P1}{P2}
	\syncmscmess{$1$}{P1}{P4}
	\syncmscmess{$(1,0)$}{P4}{P3}
	\syncmscmess{$b$}{P2}{P3}

	\syncmscmess{$(3,0)$}{P1}{P2}
	\syncmscmess{$3$}{P1}{P4}
	\syncmscmess{$(3,0)$}{P4}{P3}
	\syncmscmess{$c$}{P2}{P3}
\end{msc}
\caption{The Global Type $G_x$ showed as an MSC.}
\label{fig:exmp-mx}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{P1}{}
	\declinst{P2}{P2}{}
	\declinst{P3}{P3}{}
	\declinst{P4}{P4}{}

	\syncmscmess{$(2,0)$}{P1}{P2}
	\syncmscmess{$2$}{P1}{P4}
	\syncmscmess{$(2,0)$}{P4}{P3}
	\syncmscmess{$a$}{P2}{P3}

	\syncmscmess{$(1,1)$}{P1}{P2}
	\syncmscmess{$1$}{P1}{P4}
	\syncmscmess{$(1,1)$}{P4}{P3}
	\syncmscmess{$b$}{P2}{P3}
	\syncmscmess{$b$}{P2}{P3}

	\syncmscmess{$(3,1)$}{P1}{P2}
	\syncmscmess{$3$}{P1}{P4}
	\syncmscmess{$(3,1)$}{P4}{P3}
	\syncmscmess{$c$}{P2}{P3}
\end{msc}
\caption{The Global Type $G_y$ showed as an MSC.}
\label{fig:exmp-my}
\end{figure}

Recall that $G|_p$ denote the projection of $G$ onto process $p$. We
construct the MSC
$$
  G_{\texttt{sol}} = (G_y|_{P1},\; G_y|_{P2},\; G_x|_{P3},\; G_x|_{P4}),
$$
i.e.\ processes $1,2$ follow $G_y$ while $3,4$ follow $G_x$.
Intuitively, $G_{\texttt{sol}}$ pairs the right-side construction (from $G_y$)
with the left-side construction (from $G_x$). 
Figure~\ref{fig:exmp-msol} illustrates the behaviour of the MSC
$G_{\texttt{sol}}$. Observe that when process~3 expects to receive the
second character $\texttt{b}$ right after $a$, 
but process~2 cannot send it immediately:
it must first obtain the corresponding index and bit from process~1.
The prefix property guarantees
that every partial construction of the right-hand side is aligned with
a prefix of the left-hand side, therefore preserving synchronous
semantics throughout the execution.

\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{}{$G_y|_{P1}$}
	\declinst{P2}{}{$G_y|_{P2}$}
	\declinst{P3}{}{$G_x|_{P3}$}
	\declinst{P4}{}{$G_x|_{P4}$}

	\syncmscmess{$(2,1)$}{P1}{P2}
	\syncmscmess{$2$}{P1}{P4}
	\syncmscmess{$(2,0)$}{P4}{P3}
	\syncmscmess{$a$}{P2}{P3}
	\mess{}{P3}{P2}[4]
	\nextlevel

	\syncmscmess{$(1,0)$}{P1}{P2}
	\mess[pos=0.4]{$1$}{P1}{P4}
	\mess{}{P4}{P1}
	\nextlevel
	\syncmscmess{$(1,1)$}{P4}{P3}
	\mess[pos=0.2]{$b$}{P2}{P3}[-4]
	\nextlevel
	\syncmscmess{$b$}{P2}{P3}
	
	\syncmscmess{$(3,0)$}{P1}{P2}
	\syncmscmess{$3$}{P1}{P4}
	\syncmscmess{$(3,1)$}{P4}{P3}
	\syncmscmess{$c$}{P2}{P3}
\end{msc}
\caption{The Global Type $G_\texttt{sol}$ showed as an MSC.}
\label{fig:exmp-msol}
\end{figure}

\end{example}

The sequence of lemmas and the main theorem collectively establish the
undecidability of weak-realisability for global types. Having developed the
theoretical foundation, we now move to the next section, where we focus on the
practical aspects of analysing realisability, and introduce the \textsc{ReSCu} tool.