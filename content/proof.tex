\chapter{Weak-Realisability is Undecidable for Synch Global Types}\label{sec:proof}

As already mentioned, the first contribution is Theorem~\ref{thm:main},
which states that Weak-realisability is undecidable for synchronous global types. 
To understand this result, I have already covered the basic notions in 
Chapter~\ref{sec:pre} on MSCs, Global Types, and Weak-realisability. 
These concepts are general and align 
closely with definitions used in previously established works. 
We now introduce the main objects employed in the proof of Theorem~\ref{thm:main}. 
The proof itself is adapted from the work of 
Alur et~al.~\cite{alur2005realizability}. 
I will first give a sketch of the proof, to also highlight the 
differences with the original one.

\subsubsection*{Sketch of Proof}
The proof is carried out by a \emph{reduction} from the
\textbf{Relaxed Post Correspondence Problem (RPCP)}, a variant of
the classical Post Correspondence Problem (PCP).
The main idea is to encode the existence of a
solution to an RPCP instance into the (non-)realisability of a
\emph{global type} $L^*$ built from synchronous MSCs. 
In the original proof, $L^*$ is not a global type, but an MSC.
Therefore, we changed the base definitions of the original paper
to fit the model. 

\paragraph{Encoding:}
Given an RPCP instance $\{(v_1,w_1),\ldots,(v_m,w_m)\}$,
we associate to each pair $(v_i,w_i)$ two MSCs $M^0_i,M^1_i$,
following Definition~\ref{def:mni}. Each $M^n_i$ is \emph{synchronous}
(Lemma~\ref{lemma:minsynch}) and belongs to the language of the
global type $G_S$ (Lemma~\ref{lemma:msgs}). From all such MSCs we
build $L^*$ (Definition~\ref{def:lstar}), which represents all possible
concatenations and combination of a set of $M^n_i$'s instances.

\paragraph{Direction ``$\Rightarrow$'':}
Let's suppose $\Delta=(i_1,a_1,b_1,\ldots,i_m,a_m,b_m)$ is a solution
to the RPCP Problem.
From this, construct two MSC sequences:
\[
M_x = M^{a_1}_{i_1}\cdots M^{a_m}_{i_m}, \qquad
M_y = M^{b_1}_{i_1}\cdots M^{b_m}_{i_m}.
\]
Both $M_x,M_y$ are synchronous concatenations of synchronous MSCs.
Consider now a third MSC $M_{\texttt{sol}}$ obtained by taking the projections
$M_y|_{P1},M_y|_{P2}$ and $M_x|_{P3},M_x|_{P4}$. Intuitively, processes $P1,P2$
construct the \emph{right string} $y_{i_1}\cdots y_{i_m}$, while
processes $P3,P4$ construct the \emph{left string}
$x_{i_1}\cdots x_{i_m}$. The prefix property of RPCP ensures that
$M_{\texttt{sol}}$ is acyclic and \emph{synchronous}. 
The $M_{\texttt{sol}}$ synchrony is not trivial, therefore we need to prove it.
This part was not present in the original proof.
By construction, $L^*$ weakly
implies $M_{\texttt{sol}}$, but $M_{\texttt{sol}} \notin L^*$, since at least one tile
differs. Hence, $L^*$ is \emph{not realisable}.

\paragraph{Direction ``$\Leftarrow$'':}
Suppose $L^*$ is not realisable: then there exists some MSC $M^@$
weakly implied by $L^*$ but not in $L^*$. Analysing the projections
of $M^@$ on each process, we recover two sequences of words, one
built along processes $P1,P2$ and the other along $P3,P4$. The
fact that $M^@ \notin L^*$ implies that these two sequences must
differ at some tile, and the prefix property ensures that the word
on $P2$ is always a prefix of the word on $P3$. This yields a
\emph{solution to the RPCP instance} $\Delta$.

\bigskip

This equivalence is proved:
$$
\Delta \in \text{RPCP} \quad\iff\quad L^* \text{ is not realisable}.
$$
Since RPCP is known to be \textbf{undecidable}, it follows that
\emph{checking weak realisability of a global type is also
undecidable}.

\bigskip

Let's now define the main objects used in the proof.

\section{Definitions}
RPCP was shown to be 
undecidable by Alur~et~al.~\cite{alur2005realizability}, via reduction 
from PCP.

\bigskip

\begin{definition}[Relaxed Post Correspondence Problem]
	Given a set of tiles $\{(v_1, w_1), (v_2, w_2), ..., (v_r, w_r)\}$, 
	determine whether there exist indices $i_1, ..., i_m$ such that
	$$x_{i_1}\cdots x_{i_m} = y_{i_1}\cdots y_{i_m},$$
	where $x_{i_j}, y_{i_j} \in \{v_{i_j}, w_{i_j}\}$, such that:
	\begin{itemize}
		\item there exists at least one index $i_\ell$ for which $x_{i_\ell}\neq y_{i_\ell}$, and
		\item for all $j \leq m$, $y_{i_1}\cdots y_{i_j}$ is a prefix of $x_{i_1}\cdots x_{i_j}$.
	\end{itemize}
\end{definition}

Intuitively, RPCP requires that the concatenation on the left-hand side always 
grows at least as fast as the right-hand side, while ensuring that at least one 
chosen tile differs between the two sequences. Moreover, in constructing the 
strings, we may freely choose which element of each tile (either $v_i$ or $w_i$) 
contributes to the left or right sequence.

\bigskip

\begin{example}[Simple RPCP instance]\label{exmp:rpcp}
Consider the tile set
\[
(v_1,w_1)=(\texttt{b},\ \texttt{bb}),\quad
(v_2,w_2)=(\texttt{a},\ \texttt{ab}),\quad
(v_3,w_3)=(\texttt{c},\ \texttt{c}).
\]
Take the index sequence $(2,1,3)$ and the choices
\[
x_1 = w_2,\ y_1 = v_2;\quad
x_2 = v_1,\ y_2 = w_1;\quad
x_3 = v_3,\ y_3 = w_3.
\]
Then
\[
x_1 x_2 x_3 = \texttt{ab}\ \texttt{b}\ \texttt{c} = \texttt{abbc},
\qquad
y_1 y_2 y_3 = \texttt{a}\ \texttt{bb}\ \texttt{c} = \texttt{abbc},
\]
so the two sides are equal.

We now check the RPCP conditions:
\begin{itemize}
  \item \textbf{at least one mismatch:} here $x_1\neq y_1$ and
        $x_2\neq y_2$, so the ``some index differs'' condition holds;
  \item \textbf{prefix property:} for every prefix length $j$ we have
        $y_{1}\cdots y_{j}$ is a prefix of $x_{1}\cdots x_{j}$:
        \begin{itemize}
          \item $j=1$: $y_1=\texttt{a}$ is a prefix of $x_1=\texttt{ab}$;
          \item $j=2$: $y_1y_2=\texttt{abb}$ is a prefix of $x_1x_2=\texttt{abb}$;
          \item $j=3$: $y_1y_2y_3=\texttt{abbc}$ is a prefix of $x_1x_2x_3=\texttt{abbc}$.
        \end{itemize}
\end{itemize}
\end{example}

\bigskip

% TODO: Definire per bene le stringhe all'inizio dei preliminare
% Prima frase da spostare
\begin{definition}[$M^n_i$]\label{def:mni}
	For a string $u$, let $u^l$ denote the $l$-th character of the string.
	In the MSC $M^n_i$, process~1 synchronously sends the label
	$m_1 = (i, n)$ to process~2, then transmits the index $m_2=i$
	to process~4. Subsequently, process~4 sends $m_3 = (i, n)$
	synchronously to process~3. After these control messages, process~2
	sends the characters $m_i^1 = x_i^1,..., m_i^c = x_i^c$
	synchronously to process~3 (where $c$ is the length of $x_i$).
	This MSC is depicted in Figure~\ref{fig:mni}, where $n\in\{0,1\}$ and:
	\begin{itemize}
		\item if $n=0$, then $x_i=v_i$;
		\item if $n=1$, then $x_i=w_i$.
	\end{itemize}

	\begin{figure}[!ht]
		\centering
		\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
			\declinst{P1}{P1}{}
			\declinst{P2}{P2}{}
			\declinst{P3}{P3}{}
			\declinst{P4}{P4}{}

			\syncmscmess{$(i,n)$}{P1}{P2}
			\syncmscmess{$i$}{P1}{P4}
			\syncmscmess{$(i,n)$}{P4}{P3}
			\syncmscmess{$x_i^1$}{P2}{P3}
			\syncmscmess{...}{P2}{P3}
			\syncmscmess{$x_i^c$}{P2}{P3}
		\end{msc}
		\caption{The $M_i^n$ MSC.}
		\label{fig:mni}
	\end{figure}

\end{definition}

With this definition in place, I now introduce the main objects used 
in the proof. Specifically, I begin by showing how a Global Type can 
represent a single \verb|synch| MSC.

\bigskip

% TODO ivan: non sembra una def, più un lemma
\begin{definition}[$G_M$]\label{def:gm}
	Given an MSC $M\in \mscsetofmodel{\synchmodel}$, there exists a
	global type $G_M$ such that $\{M\} = \existentialmsclanguageof{\gt}$.
\end{definition}

We now define a particular Global Type that will be useful in the reduction.

\bigskip

\begin{definition}[$G_S$]\label{def:gs}
	Given a string $S\in\Sigma^*$, and two integers $i, n$,
	the global type $G_S$ is the global type composed of:
	\begin{itemize}
		\item $\mathbb{P}=\{p,q,r,s\}$;
		\item $\mathbb{M}=\{m_1,m_2,m_3,m_{S_1},...,m_{S_c}\}$ where
		      $m_1 = (i,n), m_2 = i, m_3 = (i,n),\\ m_{S_1} = S_1,...,m_{S_c} = S_c$ 
		      with $c = |S|$;
		\item Arr $=\{$\arrmess{p}{q}{m_1}, \arrmess{p}{s}{m_2}, \arrmess{s}{r}{m_3},
		      \arrmess{q}{r}{m_{S_1}}, ..., \arrmess{q}{r}{m_{S_c}}$\}$ where each arrow
		      denotes a synchronous message accompanied by an acknowledgment. % TODO: definisci/formalizza questa doppia freccia
	\end{itemize}
	$G_S$'s automaton is depicted in Figure~\ref{fig:gtype}.
	
	\begin{figure}[!ht]
		\centering
		\begin{tikzpicture}[->, node distance=35mm, on grid, auto]
			\node[state] (q0) {$q_0$};
			\node[state] (q1) [right=of q0] {$q_1$};
			\node[state] (q2) [right=of q1] {$q_2$};
			\node[state] (q3) [below left=of q0] {$q_3$};
			\node[state] (q4) [right=of q3] {$q_4$};
			\node[state] (q5) [right=of q4] {$\cdots$};
			\node[state,accepting] (q6) [right=of q5] {$q_x$};

			\path (q0) edge[] node[above] {\arrmess{p}{q}{(i,n)}} (q1);
			\path (q1) edge[] node[above] {\arrmess{p}{s}{i}} (q2);
			\path (q2) edge[] node[above left] {\arrmess{s}{r}{(i,n)}} (q3.60);
			\path (q3) edge[] node[above] {\arrmess{q}{r}{S_1}} (q4);
			\path (q4) edge[] node[above] {\arrmess{q}{r}{...}} (q5);
			\path (q5) edge[] node[above] {\arrmess{q}{r}{S_c}} (q6);
		\end{tikzpicture}
		\caption{The global type $G_S$.}
		\label{fig:gtype}
	\end{figure}

\end{definition}

Now, let's generalize Definition~\ref{def:gm} to include a set of MSCs.

\bigskip

\begin{definition}[$G^*$]\label{def:gstar}
	Given a set of MSCs $\mathcal{M} =\{M\ |\ M\in\mscsetofmodel{\synchmodel}\}$,
	$G^*$ is the set of global types such that $G^*=\{G_M\ |\ M \in \setmsc\}$,
	where $G_M$ is built using Definition~\ref{def:gm}.
\end{definition}

Informally, for every MSC $M\in\setmsc$ there exists a global type $G\in G^*$ that
captures the language of $M$. Now, let's build the automaton that represents
all the possible combinations and constructions of a set of MSCs.

\bigskip

\begin{definition}[The $L^*$ global type]\label{def:lstar}
	Assume a finite set $\setmsc$ of MSCs, where
	$\setmsc = \{M\ |\ M \in \mscsetofmodel{\synchmodel}\}$. Let $G^*$
	be defined as in Definition~\ref{def:gstar}.
	We define the global type $L^*_{N}$ as the automaton
	$\mathcal A = (Q,\Sigma, \delta, l_0, F)$ where:
	\begin{itemize}
		\item $Q = \{v_I,v_T\}\cup \bigcup_{G\in G^*} Q^G$;
		\item $\Sigma = \{\epsilon\}\cup\bigcup_{G\in G^*} \Sigma^G$;
		\item $\delta: Q \times \Sigma \rightarrow 2^Q$ is defined by:
			      \begin{enumerate}
				       \item $\forall G \in G^*,\ \delta(v_I, \varepsilon) = q_0^G$ where $q_0^G$ is the initial state of $G$,
				       \item $\forall G \in G^*,\ \forall q_f^G \in F^G,\ \delta(q_f^G, \varepsilon) = v_T$,
				       \item $\forall G, G' \in G^*,\ \forall q_f^G \in F^G,\ \delta(q_f^G, \varepsilon) = q_0^{G'}$.
			      \end{enumerate}
		\item $l_0 = v_I$ is the initial state;
		\item $F = v_T$ is the accepting state.
	\end{itemize}
	$L^*_N$'s automaton is depicted in Figure~\ref{fig:lstar}.
	Finally, $L^*$ is obtained by determinising $L^*_{N}$.
\end{definition}

\begin{figure}[!ht]
	\centering
	\begin{tikzpicture}[->, node distance=35mm, on grid, auto]
		\node[state] (vI) {$v_I$};
		\node[state] (qI2) [right=of vI] {$\cdots$};
		\node[state] (qI1) [above=of qI2] {$q_0^{G^1}$};
		\node[state] (qI3) [below=of qI2] {$q_0^{G^n}$};
		\node[state] (qM1) [right=of qI1] {$\cdots$};
		\node[state] (qM2) [right=of qI2] {$\cdots$};
		\node[state] (qM3) [right=of qI3] {$\cdots$};
		\node[state] (qF1) [right=of qM1] {$q_f^{G^1}$};
		\node[state] (qF2) [right=of qM2] {$\cdots$};
		\node[state] (qF3) [right=of qM3] {$q_f^{G^n}$};
		\node[state,accepting] (vT) [right=of qF2] {$v_T$};

		\path (vI) edge[] node[above] {$\epsilon$} (qI1);
		\path (vI) edge[] node[above] {$\epsilon$} (qI2);
		\path (vI) edge[] node[above] {$\epsilon$} (qI3);
		\path (qI1) edge[] node[above] {\arrmess{p}{q}{(i^{G^1},n^{G^1})}} (qM1);
		\path (qI2) edge[] node[above] {} (qM2);
		\path (qI3) edge[] node[above] {\arrmess{p}{q}{(i^{G^n},n^{G^n})}} (qM3);
		\path (qM1) edge[] node[above] {\arrmess{q}{r}{S^{G^1}_c}} (qF1);
		\path (qM2) edge[] node[above] {} (qF2);
		\path (qM3) edge[] node[above] {\arrmess{q}{r}{S^{G^n}_c}} (qF3);
		\path (qF1) edge[] node[above] {$\epsilon$} (vT);
		\path (qF2) edge[] node[above] {$\epsilon$} (vT);
		\path (qF3) edge[] node[above] {$\epsilon$} (vT);
		
		\draw (qF1.135) to [bend right=30] node[above] {$\epsilon$} (qI1.45);
		\draw (qF2.135) to [bend right=30] node[above] {$\epsilon$} (qI2.45);
		\draw (qF3.135) to [bend right=30] node[above] {$\epsilon$} (qI3.45);

		\draw (qF1.225) to node[above] {$\epsilon$} (qI2.60);
		\draw (qF3.120) to node[above] {$\epsilon$} (qI2.315);
		
		\draw (qF3) .. controls +(8,10) and +(1,3) .. node[midway,above] {$\epsilon$} (qI1);
		\draw (qF1) ..  controls +(8,-10) and +(1,-3) .. node[midway,above] {$\epsilon$} (qI3);
	\end{tikzpicture}
	\caption{The automaton of the global type $L^*_N$.}
	\label{fig:lstar}
\end{figure}

Informally, $L^*$ represents all the
possible executions of a set of MSCs. To complete the set of definitions,
let's define a particular MSC corresponding to Definition~\ref{def:gs}.

Finally, let's state the lemmas and main theorem of this work, 
along with all the proofs. 

\section{Lemmas and main proof}

Before presenting the main undecidability result, we first establish two
auxiliary lemmas that characterize the behaviour of the MSCs used in the
reduction. These lemmas will serve as building blocks for the proof of
Theorem~\ref{thm:main}.

\bigskip

\begin{lemma}\label{lemma:minsynch}
	The MSC $M_i^n$ belongs to $\mscsetofmodel{\synchmodel}$.
\end{lemma}

\begin{proof}
	By Definition~\ref{def:linearisable-msc} and
	Definition~\ref{def:synchronous},
	we need to show a linearization with all send operations
	followed by their corresponding receive operations:
	$$
	\{~!m_1?m_1\ !m_2?m_2\ !m_3?m_3\ !m_i^1?m_i^1 \ldots !m_i^c?m_i^c~\}.
	$$
	Such a linearization exists by construction, hence $M_i^n$ is synchronous.
\end{proof}

\bigskip

\begin{lemma}\label{lemma:msgs}
	The MSC $M^n_i$ (Definition~\ref{def:mni}) is included in $L(G_S)$, where $G_S$
	is the global type defined in Definition~\ref{def:gs}.
\end{lemma}

\begin{proof}
	Both $M^n_i$ and $G_S$ describe the same communication structure:
	process $p$ sends $(i,n)$ to $q$ and $i$ to $s$;
	process $s$ relays $(i,n)$ to $r$;
	process $q$ then sends the characters of $S$ (here matching $x_i$) to $r$.
	If $i,n$ and $S$ are the same, the sequence of messages is identical in both 
	$M^n_i$ and $G_S$. Since both models enforce synchronous communication, 
	their linearisations coincide. Hence, $M^n_i \in L(G_S)$.
\end{proof}

\bigskip

\begin{theorem}\label{thm:main}
	Given a global type $G$, checking if $G$ is weakly-realisable is undecidable.
\end{theorem}

\begin{proof}
	The proof proceeds via a reduction from the RPCP problem. Let's define some useful
	elements for the proof.

	Given an instance $\Delta = \{(v_1, w_1), \ldots, (v_m, w_m)\}$ of RPCP, we
	construct a set $L$ of MSCs over four processes as follows. For each pair
	$(v_i, w_i)$, we define two MSCs, $M^0_i$ and $M^1_i$, as illustrated in
	Figure~\ref{fig:mni}.
	Observe that the communication graph of each MSC is strongly connected and
	involves all four processes. Therefore, the MSC represented from
	$L^*$ and derived from $L$ is bounded.
	With the set $L$, and following the Definition~\ref{def:lstar},
	we can construct the global type $L^*$.

	We need to prove:
	\begin{center}
		$\Delta \in \text{RPCP}$ iff the global type $L^*$ is not weakly-realisable.
	\end{center}

	\begin{itemize}
		\item[$\Rightarrow$]
		      Let's assume that
		      $\Delta = (i_1, a_1, b_1, i_2, a_2, b_2, \ldots, i_m, a_m, b_m)$ are the indices
		      for a solution to a generic RPCP problem instance, and the bits $a_j$ and
		      $b_j$ indicate which string ($v_{i_j}$ or $w_{i_j}$) is chosen to go into
		      the two (left and right)
		      long strings. Consider the new MSCs $M_x$ and $M_y$ obtained from the sequences
		      $M_x = M^{a_1}_{i_1} \cdots M^{a_m}_{i_m}$ and $M_y = M^{b_1}_{i_1} \cdots M^{b_m}_{i_m}$.
		      Executions of both of these (sequences of) MSCs must exist in any
		      realisation of $L^*$. Additionally, these MSCs are in $\mscsetofmodel{\synchmodel}$
		      because they are sequence of $\mscsetofmodel{\synchmodel}$ MSC (Lemma~\ref{lemma:minsynch}).
		      $M_x$ corresponds to the construction of the left side of the equivalence of the RPCP
		      problem, and, instead, $M_y$ represents the construction of the right side.
		      We then look at the projections $M_x|_1$, $M_x|_2$, $M_x|_3$,
		      and $M_x|_4$ of $M_x$, and $M_y|_1$, $M_y|_2$, $M_y|_3$, $M_y|_4$ of $M_y$ onto the
		      4 processes. Now consider an MSC $M_{\texttt{sol}}$ formed from $M_y|_1$, $M_y|_2$,
		      $M_x|_3$, and $M_x|_4$. This MSC represent the construction of the solution to
		      the problem. Processes 1 and 2 construct the right part ($y_{i_1}...y_{i_m}$)
		      and processes 3 and 4 construct the left part ($x_{i_1}...x_{i_m}$).
		      The claim is that the combined MSC $M_{\texttt{sol}}$ is weakly
		      implied by $L^*$. By definition, the only thing to establish is that $M_{\texttt{sol}}$
		      is indeed an MSC, in the sense that it is acyclic, well-formed, complete
		      and synchronous.
		      The only new situation in terms of communication in $M_{\texttt{sol}}$ is the
		      communication between $P_1$ and $P_4$, and between $P_2$ and $P_3$.
		      But the communication between $P_1$ and $P_4$ is consistent in
		      $M_y|_1$ and $M_x|_4$ (i.e., the sequence of messages sent from $P_1$ to
		      $P_4$ in $M_y|_1$ is equal to the sequence of messages received in $M_x|_4$),
		      and the communication between $P_2$ and $P_3$ is consistent in
		      $M_y|_2$ and $M_x|_3$ because $R$ is a solution to the RPCP.
		      Furthermore, the acyclicity of $M_{\texttt{sol}}$ follows from the property of the
		      solution that the string formed by the first $j$ words on processes 1
		      and 2 is always a prefix of the string formed by the first $j$ words
		      on processes 3 and 4. Consequently, each message from $P_1$ to $P_4$
		      is sent before it needs to be received.

		      Finally, we prove that $M_{\texttt{sol}} \in \mscsetofmodel{\synchmodel}$.
		      Assume, for contradiction, that $M_{\texttt{sol}} \notin \mscsetofmodel{\synchmodel}$.
		      Then, there should be a cycle of dependencies in the communication pattern.
		      There are no communication between $P_2$ and $P_4$, and between $P_1$
		      and $P_3$. Therefore, this cycle must involve all processes, starting
		      for example from $P_1$ and having this dependency graph
		      $P_1\leftrightarrow P_2\leftrightarrow P_3\leftrightarrow P_4\leftrightarrow P_1$.
		      The only new situation that we now that can cause a cycle are the communication
		      between $P_1$ and $P_4$, and between $P_2$ and $P_3$.
		      We don't need to analyse the new communication between $P_1$ and $P_4$ because
		      it's not feasible in any communication model, but we need to analyse the one
		      between $P_2$ and $P_3$ because it's feasible in FIFO.

		      % For the fist comunication, the only possible cycle pattern is depicted
		      % in Fig.~\ref{fig:cycle1}

		      % \begin{figure}[!ht]
		      %  \centering
		      %  \begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
		      %   \declinst{P1}{P1}{}
		      %   \declinst{P2}{P2}{}
		      %   \declinst{P3}{P3}{}
		      %   \declinst{P4}{P4}{}

		      %   \mess[label position=above right,pos=0.45]{$i_z$}{P1}{P4}[8]
		      %   \nextlevel
		      %   \nextlevel
		      %   \nextlevel
		      %   \syncmscmess{($i_k,n_k)$}{P1}{P2}
		      %   \mess[label position=above,pos=0.62]{$i_k$}{P1}{P4}
		      %   \mess{}{P4}{P1}
		      %   \nextlevel
		      %   \syncmscmess{$(i_k,n_j)$}{P3}{P4}
		      %   \nextlevel
		      %   \nextlevel
		      %   \mess{}{P4}{P1}[-8]
		      %  \end{msc}
		      %  \caption{The $M_i^n$ MSC.}
		      %  \label{fig:cycle1}
		      % \end{figure}

		      % This cycle is not possible because it does not represent a
		      % solution to the RPCP problem:
		      % $x_1...x_{i_k}...x_{i_z}...x_m \neq y_1...y_{i_z}...y_{i_k}...y_m$.

		      \begin{figure}[!ht]
			      \centering
			      \begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
				      \declinst{P1}{P1}{}
				      \declinst{P2}{P2}{}
				      \declinst{P3}{P3}{}
				      \declinst{P4}{P4}{}

				      \mess[label position=above right, pos=0.3]{$c$}{P2}{P3}[4]%
				      \nextlevel
				      \syncmscmess{$(i_k,n_k)$}{P1}{P2}
				      \mess[pos=0.62]{$i_k$}{P1}{P4}%
				      \mess{}{P4}{P1}
				      \nextlevel
				      \syncmscmess{$(i_k,n_j)$}{P3}{P4}
				      \mess{}{P3}{P2}[-4]
			      \end{msc}
			      \caption{MSC communication that breaks synchrony.} % todo: modifica
			      \label{fig:cycle2}
		      \end{figure}

		      For the communication between $P_2$ and $P_3$, the only possible cycle
		      pattern is depicted in Fig.~\ref{fig:cycle2}.
		      Suppose $P_2$ wants to send a character $c$, but $P_3$
		      is not expecting any further characters. In order for
		      $P_3$ to resume receiving, it must first receive an index
		      from $P_4$. However, $P_4$ can only send this index
		      after receiving it from $P_1$, which in turn must first
		      communicate the index to $P_2$.
		      At this point, $P_2$ needs to receive the index from
		      $P_1$, but it cannot do so until it finishes sending
		      character $c$. This creates a circular dependency among the
		      processes, making the communication pattern impossible. % TODO: chiarire che non è come un caso di deadlock
		      This cycle would break the prefix property as
		      $x_1...x_{k-1}...x_m= y_1...y_{k-1}...y_m$, but the character $c$ appears
		      in $y_1...y_{k-1}$ but not in $x_1...y_{k-1}$ contradicting the
		      assumption that $y_1...y_{k-1} \leq x_1...x_{k-1}$.
		      Therefore, we conclude that $M_{\texttt{sol}} \in \mscsetofmodel{\synchmodel}$.

		      Note that $M_{\texttt{sol}}$ cannot itself be in $L^*$ because there must be
		      some index $i_j$ where $a_j \neq b_j$, and no MSC exists in $L$ where,
		      after $P_1$ announces the index, what $P_2$ sends is not
		      identical to what $P_3$ receives.

		\item[$\Leftarrow$]
		      Suppose there is some MSC $M^@$ which
		      exists in any realisation of $L^*$, but is not in $L^*$ itself. We want
		      to derive a solution to $\Delta$ from $M^@$.
		      First, it is clear that the projection $M^@|_1$ must consist of a sequence
		      of pairs of messages (the first of each pair acknowledged), sent from
		      process 1 to processes 2 and 4, respectively, with messages $(i, b)$ and $i$.
		      Likewise, it is clear that, in order for process 2 to receive those messages,
		      $M^@|_2$ must consist of a sequence of receipts of $(i, b)$ pairs, and after
		      each $(i, b)$, either $v_i$ or $w_i$ is sent to process 3, based on whether
		      $b = 0$ or $b = 1$, before the next index pair is received.
		      Likewise, $M^@|_4$ consists of a sequence of receipts of index $i$ from
		      process 1, followed by sending of $(i, 0)$ or $(i, 1)$ to process 3, and
		      $M^@|_3$ consists of a sequence of receipt of $(i, 0)$ or $(i, 1)$ followed
		      by receipt of $v_i$ or $w_i$, respectively.
		      Now, since $M^@$ is not in $L^*$, for some index $i$ the choice of $v_i$ or
		      $w_i$ must differ on process 2 and process 3. (Note, we are assuming that
		      the buffers between processes are FIFO.)
		      Furthermore, because of the precedences, the prefix formed by the first
		      $j$ words on process 2 must precede the $(j + 1)$-th message from
		      process 1 to process 4, which in turn precedes the $(j + 1)$-th message
		      from 4 to 3, and hence the $(j + 1)$-th word on process 3. That is, the
		      string formed by the first $j$ words on process 2 is a prefix of the string
		      formed by the first $j$ words on process 3. Therefore, we can readily
		      build a solution for $\Delta$ from $M^@$ by building the strings of the solution
		      taking the projections of $P_1$ and $P_4$. In fact, $P_1$ builds 
			  $y_{i_1}\cdots y_{i_m},$ and $P_4$ builds $x_{i_1}\cdots x_{i_m}$.

	\end{itemize}

\end{proof}

In this example, I will show the step-by-step construction 
of $M_{\texttt{sol}}$ from Theorem~\ref{thm:main}.

\bigskip

% TODO: dare un esempietto per far vedere che la prova regge
\begin{example}[$M_{\texttt{sol}}$ Example of Theorem~\ref{thm:main}]
Consider the tiles and the solution of the RPCP instance 
in Example~\ref{exmp:rpcp}, with the tile set and the solution
with index sequence $(2,1,3)$
$$
 (v_1,w_1)=(\texttt{b},\texttt{bb}),\ 
 (v_2,w_2)=(\texttt{a},\texttt{ab}),\ 
 (v_3,w_3)=(\texttt{c},\texttt{c}).
$$
$$
 x_1=w_2,\ y_1=v_2;\quad x_2=v_1,\ y_2=w_1;\quad x_3=v_3,\ y_3=w_3
$$
This sequence is a solution because
$x_1x_2x_3=\texttt{ab}\,\texttt{b}\,\texttt{c}=\texttt{abbc}$ and
$y_1y_2y_3=\texttt{a}\,\texttt{bb}\,\texttt{c}=\texttt{abbc}$. The
prefix property and the ``some index differs'' condition are satisfied.

Therefore, the encoding of the solution is
$$\Delta = (i_1=2,a_1=1,b_1=0,i_2=1,a_2=0,b_2=1,i_3=3,a_3=0,b_3=1)$$

Recall that for each tile index \(i\) we have two synchronous MSCs
\(M_i^0\) and \(M_i^1\) (see Definition~\ref{def:mni}), where the bit
indicates choosing \(v_i\) (0) or \(w_i\) (1) for the character stream.
Using the concrete index sequence \((2,1,3)\) we form two
concatenated MSCs:
\[
  M_x\;=\; M^{1}_{2}\ \cdot\ M^{0}_{1}\ \cdot\ M^{0}_{3},
\qquad
  M_y\;=\; M^{0}_{2}\ \cdot\ M^{1}_{1}\ \cdot\ M^{1}_{3}.
\]
Here \(M\) encodes the \(\mathbf{x}\)-concatenation
\((x_1,x_2,x_3)=(w_2,v_1,v_3)\) (depicted 
in Figure~\ref{fig:exmp-mx}) and \(M_y\) encodes 
the \(\mathbf{y}\)-concatenation (depicted in 
Figure~\ref{fig:exmp-my}) \((y_1,y_2,y_3)=(v_2,w_1,w_3)\).

\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{P1}{}
	\declinst{P2}{P2}{}
	\declinst{P3}{P3}{}
	\declinst{P4}{P4}{}

	\syncmscmess{$(2,1)$}{P1}{P2}
	\syncmscmess{$2$}{P1}{P4}
	\syncmscmess{$(2,1)$}{P4}{P3}
	\syncmscmess{$a$}{P2}{P3}
	\syncmscmess{$b$}{P2}{P3}

	\syncmscmess{$(1,0)$}{P1}{P2}
	\syncmscmess{$1$}{P1}{P4}
	\syncmscmess{$(1,0)$}{P4}{P3}
	\syncmscmess{$b$}{P2}{P3}

	\syncmscmess{$(3,0)$}{P1}{P2}
	\syncmscmess{$3$}{P1}{P4}
	\syncmscmess{$(3,0)$}{P4}{P3}
	\syncmscmess{$c$}{P2}{P3}
\end{msc}
\caption{The MSC $M_x$}
\label{fig:exmp-mx}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{P1}{}
	\declinst{P2}{P2}{}
	\declinst{P3}{P3}{}
	\declinst{P4}{P4}{}

	\syncmscmess{$(2,0)$}{P1}{P2}
	\syncmscmess{$2$}{P1}{P4}
	\syncmscmess{$(2,0)$}{P4}{P3}
	\syncmscmess{$a$}{P2}{P3}

	\syncmscmess{$(1,1)$}{P1}{P2}
	\syncmscmess{$1$}{P1}{P4}
	\syncmscmess{$(1,1)$}{P4}{P3}
	\syncmscmess{$b$}{P2}{P3}
	\syncmscmess{$b$}{P2}{P3}

	\syncmscmess{$(3,1)$}{P1}{P2}
	\syncmscmess{$3$}{P1}{P4}
	\syncmscmess{$(3,1)$}{P4}{P3}
	\syncmscmess{$c$}{P2}{P3}
\end{msc}
\caption{The MSC $M_y$}
\label{fig:exmp-my}
\end{figure}

Recall that $M|_p$ denote the projection of $M$ onto process $p$. We
construct the MSC
$$
  M_{\texttt{sol}} = (M_y|_{P1},\; M_y|_{P2},\; M_x|_{P3},\; M_x|_{P4}),
$$
i.e.\ processes $1,2$ follow $M_y$ while $3,4$ follow $M_x$.
Intuitively, $M_{\texttt{sol}}$ pairs the right-side construction (from $M_y$)
with the left-side construction (from $M_x$). 
Figure~\ref{fig:exmp-msol} illustrates the behaviour of the MSC
$M_{\texttt{sol}}$. Observe that when process~3 expects to receive the
second character $\texttt{b}$ right after $a$, 
but process~2 cannot send it immediately:
it must first obtain the corresponding index and bit from process~1.
The prefix property guarantees
that every partial construction of the right-hand side is aligned with
a prefix of the left-hand side, therefore preserving synchronous
semantics throughout the execution.

\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{}{$M_y|_{P1}$}
	\declinst{P2}{}{$M_y|_{P2}$}
	\declinst{P3}{}{$M_x|_{P3}$}
	\declinst{P4}{}{$M_x|_{P4}$}

	\syncmscmess{$(2,1)$}{P1}{P2}
	\syncmscmess{$2$}{P1}{P4}
	\syncmscmess{$(2,0)$}{P4}{P3}
	\syncmscmess{$a$}{P2}{P3}
	\mess{}{P3}{P2}[4]
	\nextlevel

	\syncmscmess{$(1,0)$}{P1}{P2}
	\mess[pos=0.4]{$1$}{P1}{P4}
	\mess{}{P4}{P1}
	\nextlevel
	\syncmscmess{$(1,1)$}{P4}{P3}
	\mess[pos=0.2]{$b$}{P2}{P3}[-4]
	\nextlevel
	\syncmscmess{$b$}{P2}{P3}
	
	\syncmscmess{$(3,0)$}{P1}{P2}
	\syncmscmess{$3$}{P1}{P4}
	\syncmscmess{$(3,1)$}{P4}{P3}
	\syncmscmess{$c$}{P2}{P3}
\end{msc}
\caption{The MSC $M_\texttt{sol}$}
\label{fig:exmp-msol}
\end{figure}

\end{example}

The sequence of lemmas and the main theorem collectively establish the
undecidability of weak-realisability for global types. Having developed the
theoretical foundation, we now move to the next section, where we focus on the
practical aspects of analysing realisability, and introduce the \textsc{ReSCu} tool.