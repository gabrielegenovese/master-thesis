\chapter{Preliminaries}\label{sec:pre}
In this section, the fundamental concepts and definitions necessary 
to contextualize the main contributions of this work are presented. 
I, first, introduce Message Sequence Charts (MSC), followed by 
an examination of communication model's semantics that are particularly interesting. 
Then, the notions of Global Type and Realizability are 
defined within the scope of this work, along with the foundational 
elements required to understand the theoretical contributions.

\section{MSCs and the Synchronous Communication Model}

% TODO: check definizione del paper PPDP
\begin{definition}[Message Sequence Chart]\label{def:msc}
Let $\mathbb{P}$ be a finite set of processes and $\mathbb{M}$ a set of messages.
Let $\Sigma$ be a set of send and receive actions denoted as $\mathrm{send}(p,q,m)$
and $\mathrm{rec}(p,q,m)$, where $p,q \in \mathbb{P}$ and $m\in \mathbb{M}$.
An MSC over $(\mathbb{P}, \mathbb{M})$ is a tuple
$M = (\mathcal{E}, \rightarrow, \vartriangleleft, \lambda)$ where:
$\mathcal{E}$ is a finite (possibly empty) set of \emph{events};
$\lambda : \mathcal{E} \to \Sigma$ is a \emph{labelling function} assigning an action to each event;
$\rightarrow$ and $\vartriangleleft$ are binary relations on $\mathcal{E}$ satisfying the conditions below.
The projection of an MSC $M$ onto a process $i \in \mathbb{P}$ is denoted by $M|_i$.
For each process $p \in \mathbb{P}$, define
$\mathcal{E}_p = \{\, e \in \mathcal{E} \mid \lambda(e) \in \Sigma_p \,\}$
as the set of events executed by $p$.
\begin{enumerate}
    \item \textbf{Process relation.}  
    The relation $\rightarrow \subseteq \mathcal{E} \times \mathcal{E}$ relates an event to its immediate successor on the same process:
    $\rightarrow \;=\; \bigcup_{p \in \mathbb{P}} \rightarrow_p$
    where $\rightarrow_p \subseteq \mathcal{E}_p \times \mathcal{E}_p$ is the direct successor relation of a total order on $\mathcal{E}_p$.

    \item \textbf{Message relation.}  
    The relation $\vartriangleleft \subseteq \mathcal{E} \times \mathcal{E}$ relates matching send/receive events, satisfying:
    \begin{itemize}
        \item For every $(e,f) \in \vartriangleleft$, there exist processes $p,q \in \mathbb{P}$ and a message $m \in \mathbb{M}$ such that  
        $\lambda(e) = \mathrm{send}(p,q,m)$ and $\lambda(f) = \mathrm{rec}(p,q,m)$.
        \item For every receive event $f$ with $\lambda(f) = \mathrm{rec}(p,q,m)$, there exists exactly one $e \in \mathcal{E}$ such that $e \vartriangleleft f$.
        \item For every send event $e$ with $\lambda(e) = \mathrm{send}(p,q,m)$, there exists at most one $f \in \mathcal{E}$ such that $e \vartriangleleft f$.
    \end{itemize}

    \item \textbf{Happens-before relation.}  
    The \emph{happens-before} relation is defined as
    $\le_{\mathrm{hb}} \;=\; (\rightarrow \,\cup\, \vartriangleleft)^{*}$
    and is required to be a partial order on $\mathcal{E}$.
\end{enumerate}
\end{definition}

\bigskip

\begin{example}\label{exmp:msc}
Consider the following example of an MSC.  
It consists of three processes $P1,P2,P3$ and three messages $m_1,m_2,m_3$.  
The set of events $\mathcal{E}$ is given by the following elements:  
$\mathrm{send}(P1,P2,m_1)$ as $e_1$,  
$\mathrm{rec}(P1,P2,m_1)$ as $e_2$,  
$\mathrm{send}(P2,P1,m_2)$ as $e_3$,  
$\mathrm{rec}(P2,P1,m_2)$ as $e_4$,  
$\mathrm{send}(P2,P3,m_3)$ as $e_5$,  
$\mathrm{rec}(P2,P3,m_3)$ as $e_6$.  
The process relation $\rightarrow$ orders events along each process:  
on $P1$: $e_1 \rightarrow e_4$;  
on $P2$: $e_2 \rightarrow e_3 \rightarrow e_5$;  
on $P3$: $e_6$.  
The message relation $\vartriangleleft$ pairs $e_1 \vartriangleleft e_2$,  
$e_3 \vartriangleleft e_4$, and $e_5 \vartriangleleft e_6$.  
The happens-before relation $\le_{\mathrm{hb}}$ is the transitive closure  
of these, yielding dependencies such as  
$e_1 \le_{\mathrm{hb}} e_2 \le_{\mathrm{hb}} e_3 \le_{\mathrm{hb}} e_4$  
and $e_3 \le_{\mathrm{hb}} e_5 \le_{\mathrm{hb}} e_6$.  
Figure~\ref{fig:msc-exmp} depicts the described example.
	
\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{P1}{}
	\declinst{P2}{P2}{}
	\declinst{P3}{P3}{}

	\mess{$m_1$}{P1}{P2}
	\nextlevel
	\mess{$m_2$}{P2}{P1}
	\nextlevel
	\mess{$m_3$}{P2}{P3}
\end{msc}
\caption{Simple example with an exchange of three messages.}
\label{fig:msc-exmp}
\end{figure}
\end{example}

First, we introduce the definition of a linearisation of an MSC. A
linearisation represents a possible ordering of the events in the distributed
system, that is, a way to schedule the events of an MSC.

\bigskip

\begin{definition}[Linearisation of a MSC]
	Let $M = (\mathcal{E}, \Rightarrow, \triangleleft, \lambda)$ be an MSC.
	A \emph{linearisation} of $M$ is a (reflexive) total order
	$\rightsquigarrow \subseteq \mathcal{E} \times \mathcal{E}$ such that
	$\leq_{hb} \subseteq \rightsquigarrow$. 
\end{definition}

% TODO: dare più contesto

% An MSC $M = (E, \to, \lhd, \lambda)$ is an \verb|rsc|-MSC if it has no unmatched 
% send events and there is a linearisation $\rightsquigarrow$ where any 
% matched send event is immediately followed by its respective receive event.

\bigskip

\begin{example}\label{exmp:lin}
Considering the Example~\ref{exmp:msc}, three possible linearisation
are 
$$e_1 \rightsquigarrow e_2 \rightsquigarrow e_3 \rightsquigarrow e_4
\rightsquigarrow e_5 \rightsquigarrow e_6\ ;$$
$$e_1 \rightsquigarrow e_2 \rightsquigarrow e_3 \rightsquigarrow e_5
\rightsquigarrow e_4 \rightsquigarrow e_6$$ and
$$e_1 \rightsquigarrow e_2 \rightsquigarrow e_3 \rightsquigarrow e_5
\rightsquigarrow e_6 \rightsquigarrow e_4.$$ 
\end{example}

We write $\linearisationsof{\mmsc}{}$ for the set of all linearisations of $\mmsc$.
Given an MSC $\mmsc$, we write $\linearisationsof{\mmsc}{\acommunicationmodel}$ 
to denote $\linearisationsof{\mmsc}{} \cap \mathcal{E}_{\text{com}}$;
the executions of $\linearisationsof{\mmsc}{\acommunicationmodel}$ 
are called the linearisations of $\mmsc$ in the communication model \verb|com|.

\bigskip
	
\begin{definition}[$\acommunicationmodel$-linearisable MSC]\label{def:linearisable-msc}
	An MSC $\mmsc$ is \textit{linearisable} in a communication model $\acommunicationmodel$
	if $\linearisationsof{\mmsc}{\acommunicationmodel}\neq\emptyset$.
	We write $\mscsetofmodel{\acommunicationmodel}$ for the set of all MSCs 
	linearisable in $\acommunicationmodel$.
\end{definition}

Finally, let's formally define what is a \verb|synch|-MSCs in this context.
% TODO: dare più contesto 

\bigskip

%% TODO: per ivan è un po' criptica
\begin{definition}[Synchronous execution]\label{def:synch}
	An execution $\execution=(w,\source) \in \executionsofmodel{\synchmodel}$
	if for all send event $s\in\sendeventsof{e}$, $s+1$ is a receive event
	of $e$ and $\source(s+1)=s$.
\end{definition}

% TODO: dare più contesto

In other words, an MSC $M$ belongs to $\mscsetofmodel{\synchmodel}$ if
all send events are immediately followed by their corresponding receive events.

\bigskip

\begin{example}
Consider the Example~\ref{exmp:msc} and the respective linearisation
listed in  Example~\ref{exmp:lin}. 
The MSC $\mmsc$ is \textit{linearisable} in the $\synchmodel$ communication 
model because
$\linearisationsof{\mmsc}{\synchmodel}\neq\emptyset$.
The only element of $\linearisationsof{\mmsc}{\synchmodel}$ is
$$e_1 \rightsquigarrow e_2 \rightsquigarrow e_3 \rightsquigarrow e_4
\rightsquigarrow e_5 \rightsquigarrow e_6.$$
All the send events ($e_1, e_3, e_5$) are followed by the respective
receive events ($e_2, e_4, e_6$).
\end{example}

\section{Basic notions for Global Types}
This part will further highlight the basic notions to understand the formal proof 
for the theorem presented in Section~\ref{sec:proof} and, in particular, Global Type
and Weakly-realizable. We begin by extending the definition of linearisability so 
that it applies to all communication models.
In our setting, Global Types are automata that describe a language of MSCs, 
as considered in this recent work by Di Giusto, et al.~\cite{di2025realisability}.

%% TODO: commenti di ivan: non è proprio un type, lui definisce 
%% così i choreography automata , magari specificare che le definizioni corrispondono
%% e citare il paper che usa questa nozione

%% !! CA da citare nei related 

\bigskip

\begin{definition}[Global Type]
	An \emph{arrow} is a triple $(p,q,m)\in\Procs\times\Procs\times\Messages$ 
	with $p\ne q$; we often write $\marrow{p}{q}{m}$ instead of $(p,q,m)$, and 
	write $\labelalphabet$ to denote the finite set of arrows.
	A Global Type $\gt$ is a deterministic finite state automaton over the 
	alphabet $\labelalphabet$.
\end{definition}
% TODO: dare più contesto ad esempio

\bigskip

\begin{example}
An example of a Global Type expressed as an automaton is the following.
Consider the not-implementable specification stated in 
Listing~\ref{lst:not-impl-exm}. The protocol can be modelled with the 
Global Type in Figure~\ref{fig:gt-exm}.

\begin{figure}[!ht]
	\centering
	\begin{tikzpicture}[node distance=1.5cm, auto, scale=0.8]
		\node[state, initial, initial text={}] (s0) {1};
			\node[state] (s1) [above right=of s0] {2};
			\node[state] (s2) [below right=of s0] {3};
			\node[state,accepting] (s3) [right=of s1] {4};
			\node[state,accepting] (s4) [right=of s2] {5};

			\draw[->] (s0) to node[above,sloped]{$\gtlabel{A}{B}{x}$}(s1);
			\draw[->] (s0) to node[above,sloped]{$\gtlabel{A}{B}{y}$}(s2);
			\draw[->] (s1) to node[above,sloped]{$\gtlabel{C}{D}{z}$}(s3);
			\draw[->] (s2) to node[above,sloped]{$\gtlabel{C}{D}{w}$}(s4);
			
		\end{tikzpicture}
		\caption{An automaton representing the specification's global type given in Listing~\ref{lst:not-impl-exm}.}
		\label{fig:gt-exm}
	\end{figure}
\end{example}

Let's continue defining the basic notions of
automaton and communicating finite state machines.
% I assume standard notations for automata, words, and languages.  % TODO rifrasa? definisci?

\bigskip

\begin{definition}[NFA]
    A nondeterministic finite automaton (NFA) is a tuple 
    $\mathcal A = (Q, \Sigma, \delta, l_0, F)$, where $Q$ is the set of states, 
    $\Sigma$ the alphabet, $\delta : Q \times \Sigma \to 2^Q$ the transition relation, 
    $l_0$ the initial state, and $F \subseteq Q$ the set of accepting states. 
    The language $\languageofnfa{\mathcal A}$ of an NFA $\mathcal A$ and the notion of deterministic
    finite state automaton (DFA) or $\varepsilon$ transitions are defined as usual.
    We denote by $\languageofnfa{\mathcal A}$ the language of $\mathcal A$. 
    % We write $\acceptcompletion{\mathcal A}{}$ for the automaton 
	% obtained from $\mathcal A$ by setting $F=Q$. % TODO: lo uso?
    % Deterministic automata and $\varepsilon$-transitions are defined in the standard way.   % TODO rifrasa? definisci?
\end{definition}

Furthermore, we recall the definition of communicating finite state machines~\cite{BrandZafiropulo}.

\bigskip

\begin{definition}[CFSM] \label{def:cfsm}
    A \emph{communicating finite state machine} (CFSM) is an NFA with 
    $\varepsilon$-transitions $\acfsm$ over the alphabet $\Act$.  
    A system of CFSMs is a tuple $\cfsms = (\acfsm_p)_{p \in \Procs}$.
\end{definition}

These definitions will later be used also for Chapter~\ref{sec:rescu}.
Let's now define the asynchronous product of an automaton

\bigskip

\begin{definition}[Asynchronous product automaton]
Let $\{A_i\}_{i=1}^n$ be a set of automata. For each ordered pair 
$(i,j)$ of process indices, we use two buffers: $B^s_{i,j}$ 
(pending messages sent by $P_i$ but not yet accessible by $P_j$) 
and $B^r_{i,j}$ (messages delivered to $P_j$ but not yet consumed). 
All buffers are words over the alphabet $\Sigma$.

The asynchronous product automaton 
$A = \prod_{i=1}^n A_i$ over $\hat{\Sigma}$ is given by: % TODO: capire cos'è \hat{\Sigma}

\begin{itemize}
  \item \textbf{States:} A state $q$ consists of the local states 
  $q_i$ of each $A_i$, together with the buffer contents.
  \item \textbf{Initial state:} $q_0$ has all components in their 
  start states $q_i^0$ and all buffers empty.
  \item \textbf{Transitions:} $\delta \subseteq Q \times 
  (\hat{\Sigma} \cup \{\tau\}) \times Q$.
    \begin{enumerate}
      \item For $x \in \hat{\Sigma}_i$, $(q,x,q') \in \delta$ iff:  
      (a) states of all other processes $k \neq i$ are unchanged,  
      (b) $(q_i,x,q'_i) \in \delta_i$,  
		% TODO: capire semantica dei buffer dal paper di Alur
      (c) if $x = receive(j,i,a)$ then the buffer $B^r_{j,i}$ consume the message $a$ (if present),  
      (d) if $x = send(i,j,a)$ then the message $a$ is appended in the buffer $B^s_{i,j}$,  
      (e) all other buffers remain unchanged.
      \item There is a $\tau$-transition $(q,\tau,q')$ if $q$ and 
      $q'$ differ only in that one buffer $B^s_{i,j}$ loses its 
      head symbol $a$, and $B^r_{i,j}$ appends $a$.
    \end{enumerate}
  \item \textbf{Accepting states:} $q$ is accepting if all $q_i$ 
  are accepting and all buffers are empty.
\end{itemize}

The language $L(A)$ of $A$ consists of all words in $\hat{\Sigma}^*$ 
taking $q_0$ to an accepting state, interpreting $\tau$ as 
$\varepsilon$. For any set of automata $\{A_i\}$, the language 
$L(\prod_i A_i)$ contains only complete, well-formed words. For a 
given MSC $M$, $L(\prod_i A_i)$ either contains all linearisations 
of $M$, or none.
\end{definition}

% TODO: dare più contesto ed esempio


% --------------relationship between MSCs and Global Types--------------

I can now formally define the relationship between MSCs and Global Types. 
Intuitively, Global Types represent a set of MSCs, allowing us to reason 
about multiple message sequence scenarios. 

A Global Type defines a language of MSCs in two different ways, one
existential and one universal. Let $\labellanguageof{\gt}$ be the set of
sequences of arrows $w$ accepted by $\gt$. Note that for $w \in \Arrows^*$,
the function $w \mapsto \labeltomsc{w}$ with
$\labeltomsc{w} \in \mscsetofmodel{\synchmodel}$ is not injective, as two
arrows with disjoint pairs of processes commute. We write $w_1 \sim w_2$ if
$\labeltomsc{w_1} = \labeltomsc{w_2}$, and $[w]$ for the equivalence class
of $w$ with respect to $\sim$.

Informally, the existential MSC language $\existentialmsclanguageof{\gt}{}$ of a 
Global Type $\gt$ is the set of MSCs that admit at least one representation as a
sequence of arrows in $\labellanguageof{\gt}$, and the universal MSC
language $\universalmsclanguageof{\gt}$ of a Global Type $\gt$ is the set of
MSCs whose representations as sequences of arrows are all in
$\labellanguageof{\gt}$:
% TODO: ivan dice di controllare? la def di chor automata (o forse hanno una roba simile)

\bigskip

\begin{definition}[$\existentialmsclanguageof{\gt}$]
	$$
		\existentialmsclanguageof{\gt} \eqdef \{\labeltomsc{w} \mid
		w \in \labellanguageof{\gt}\}
  $$
\end{definition}

\bigskip

\begin{definition}[$\universalmsclanguageof{\gt}$]
  $$
		\universalmsclanguageof{\gt} \eqdef \{\labeltomsc{w} \mid
		[w] \subseteq \labellanguageof{\gt}\}.
	$$
\end{definition}
% TODO: dare più contesto ed esempio

\bigskip

\begin{definition}[Commutation-closed]
    A global type $\gt$ is \emph{commutation-closed} if
    $$
    \existentialmsclanguageof{\gt} = \universalmsclanguageof{\gt}.
    $$
\end{definition}
% TODO: togliere exist e forall dalla nozione
% We write $\msclanguageofcc{\gt}$ for the common language. % TODO: mi serve?

I now introduce the definition of implementability following the one given 
by Alur, et al. \cite{alur2005realizability}, referred to as 
\textit{Weak-realizability}.
To formalize it, we first define the notions of 
\textit{weak implication} and \textit{weak closure}.

%% TODO: Spiegare meglio con intuizioni

\bigskip

\begin{definition}[Weakly-imply]
	Let $\setmsc$ be a set of MSCs and $M$ an MSC. $\setmsc$
	\textit{weakly implies} $M$, if for any sequence of automata
	$\langle A_i \ |\ 1\leq i\leq n\rangle$, if every MSC in $\setmsc$ is in
	$L(\prod_i A_i)$ then $M \in L(\prod_i A_i)$.
\end{definition}

In order to understand the meaning of \emph{weak implication},
consider the following example.

\bigskip

\begin{example}
Define two MSCs, MSC1 and MSC2. Both perform the same four
communications, but in different orders.  
MSC1 first sends message $a$ from P1 to P2, then from P1 to P3, 
then sends $b$ from P4 to P2, and finally from P4 to P3.  
MSC2 instead starts with P4 sending $b$ to P2, then to P3, 
followed by P1 sending $a$ to P2 and then to P3.  

Now define a third MSC $M$ with the same four messages but in a
different order: P1 sends $a$ to P2, P4 sends $b$ to P2, P4 sends 
$b$ to P3, and finally P1 sends $a$ to P3.  

We say $M$ is weakly implied by MSC1 and MSC2. Indeed, by looking
at each process projection we recover the same behaviour in one of
them: for P1 and P4 in both, for P2 in MSC1, and for P3 in MSC2.  
Figure~\ref{fig:weak-impl} illustrates the three MSCs.

\begin{figure}[!ht]
\centering
\begin{tabular}{ccc}
\begin{minipage}{0.32\textwidth}
\scalebox{0.55}{%
\begin{msc}[left environment distance=0cm, draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{P1}{}
	\declinst{P2}{P2}{}
	\declinst{P3}{P3}{}
	\declinst{P4}{P4}{}

	\mess{a}{P1}{P2}
	\nextlevel
	\mess[pos=0.25]{a}{P1}{P3}
	\nextlevel
	\nextlevel
	\mess[pos=0.25]{b}{P4}{P2}
	\nextlevel
	\mess{b}{P4}{P3}
\end{msc}
} 
\end{minipage}
&
\begin{minipage}{0.32\textwidth}
\scalebox{0.55}{%
\begin{msc}[left environment distance=0cm, draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{P1}{}
	\declinst{P2}{P2}{}
	\declinst{P3}{P3}{}
	\declinst{P4}{P4}{}

	\mess[pos=0.25]{b}{P4}{P2}
	\nextlevel
	\mess{b}{P4}{P3}
	\nextlevel
	\nextlevel
	\mess{a}{P1}{P2}
	\nextlevel
	\mess[pos=0.25]{a}{P1}{P3}
\end{msc}
}
\end{minipage}
&
\begin{minipage}{0.32\textwidth}
\scalebox{0.55}{%
\begin{msc}[left environment distance=0cm, draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{P1}{}
	\declinst{P2}{P2}{}
	\declinst{P3}{P3}{}
	\declinst{P4}{P4}{}

	\mess{a}{P1}{P2}
	\nextlevel
	\mess[pos=0.25]{b}{P4}{P2}
	\nextlevel
	\nextlevel
	\mess{b}{P4}{P3}
	\nextlevel
	\mess[pos=0.25]{a}{P1}{P3}
\end{msc}
}
\end{minipage} \\
MSC1 & MSC2 & $M$
\end{tabular}
\caption{The MSC $M$ is weakly implied by MSC1 and MSC2}
\label{fig:weak-impl}
\end{figure}
\end{example}

\bigskip

\begin{definition}[Weakly-closure $\setmsc^w$]
	The weak-closure $\setmsc^w$ of a set $\setmsc$ of MSCs contains all the MSCs
	weakly implied by $\setmsc$.
\end{definition}

% todo: esempio

\bigskip

\begin{definition}[Weakly-realizable]
	An MSC $M$ is said to be weakly-realizable if the set of MSCs
	$L(M)$ is weakly realizable. A set of MSCs $\setmsc$ is said to be weakly
	realizable if $\setmsc=\setmsc^w$.
\end{definition}
It is important to note that this definition does not include the
property of deadlock-freedom. 

% todo: esempio

% CINZIA, X TESI:
% sarebbe interessante mettere la definizione di PPDP e mostrare 
% l'equivalenza tra le due

% VERSIONE ALTERNATIVA VECCHIA
% \begin{definition}[Projection]
% For an MSC $M$ and a process $P_i$, let $M|_i$ denote the sequence of events be
% belonging to the process $P_i$ in $M$.
% \end{definition}
% \begin{definition}[Weakly-imply]
% The set of MSCs $\setmsc$ weakly implies an MSC $M$ iff for all $1\leq i\leq n$, there
% exist an MSC $M_i\in L$ such that $M|_i=M_i|_i$
% \end{definition}
% \begin{definition}[Weakly-realizable]
% ? TODO ?
% \end{definition}

We are now ready to present the main contributions of this work.


