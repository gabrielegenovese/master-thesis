\chapter{Introduction} \label{chap:intro}
\pagestyle{plain}
\setcounter{page}{1}

Informally, a \textit{distributed system} is a collection of independent 
computing entities (called also processes, actors, 
nodes, or participants; with slightly differences in the meaning) 
that communicate and coordinate their 
actions through message passing over a medium of communication 
(typically an \textbf{asynchronous network}), with the goal of solving a 
common problem. For example, a client-server application can be seen 
as a form of distributed system, where the shared objective is to provide 
services to an end user.

Distributed systems make it possible to address challenges that are
hard to solve without such an architecture, such as high availability
and elastic scalability. However, these benefits come with their own
set of challanges that computer scientists need to
address, for example, ensuring reliability in the presence of failures
in critical systems, and maintaining data consistency.
Distributed systems are 
widely adopted in domains such as \textit{cloud computing}, critical 
infrastructures, and telecommunication-oriented applications (i.e.\ 
autonomous cars, aerospace systems, etc.). Given their ubiquity, it is 
crucial to study every aspect of their \textbf{design}, \textbf{execution}, 
and \textbf{verification}.
To manage these complexities in a mathematical way, researchers rely on
formal abstractions and rigorous methodologies. These allow us to move
from ad-hoc engineering practices to systematic approaches with
provable guarantees.

One recurring difficulty in distributed systems' development is writing 
\textbf{correct programs}. Avoiding programming and logical errors is 
inherently hard, even for experienced developers. To mitigate this, many 
abstractions have been introduced, and computer scientists have focused their 
efforts on developing \textit{formal frameworks} that provide guarantees 
about program behavior. 

Formal methods for distributed systems offer mathematically rigorous 
techniques to specify, design, and verify such systems. They are valuable 
both during design and development, by helping detect errors early, and during analysis, 
by enabling the study of critical properties such as \textbf{safety}, 
\textbf{liveness}, and \textbf{deadlock-freedom}. Two primary 
approaches are \textit{model checking} verification and 
\textit{correctness by-construction}.
Model checking systematically explores a system's state space 
to confirm properties, while by-construction verification ensures correctness 
through the design process itself, preventing errors from being introduced.  

Among the many aspects of distributed systems, communication is particularly 
prone to subtle errors and inconsistencies. To reason formally about 
communication protocols, several models have been proposed, including the 
Calculus of Communicating Systems (CCS), the $\pi$-calculus, and choreographies. 
In this context, \textit{Multiparty Session Types} (MPST)~\cite{honda2008multiparty} 
stand out as a powerful framework. MPST are designed specifically to formalize 
and verify structured communication among multiple participants, providing 
strong guarantees about protocol correctness.  

MPST describe communication through a \emph{global type}, which specifies 
the entire interaction among all participants. This global type is then 
\emph{projected} into \emph{local types}, one for each participant. Local 
types act as contracts, ensuring that each component adheres to the protocol. 
As a result, MPST allow developers to guarantee properties such as 
deadlock-freedom and protocol compliance at compile time, making them an 
especially appealing tool for designing robust communication protocols.

\section{Goal}
The goal of this work is to investigate the \textbf{realisability
problem} for MPST, which asks whether a global specification can be
faithfully realised by a collection of \textit{local processes} in a
distributed system. This question naturally arises in top-down
development methodologies, such as MPST or choreographic
frameworks~\cite{montesi2014choreographic}, where the design begins
from a \emph{global perspective} and the local behaviour of each
participant is derived afterwards.

The realisability problem is central to ensuring that the
distributed implementation does not diverge from the intended
specification. In essence, the challenge is to determine whether the
set of projected local processes can really \textbf{respect} the
behaviour prescribed by the global model, while preserving essential
properties such as correctness, progress, and deadlock-freedom. 

A releted-work analysis is provided in
Chapter~\ref{sec:rel}, where we examine how similar problems have been
addressed in other formal frameworks.
To illustrate the relevance of this problem, consider the following
example.

\bigskip

\begin{example}
Consider four processes $A, B, C,$ and $D$ communicating over an
asynchronous network, with four messages $x, y, z,$ and $w$ to be
exchanged as specified in Listing~\ref{lst:not-impl-exm}. A natural
question arises: can such a specification be faithfully implemented in a
real distributed system?

\bigskip

\begin{lstlisting}[caption={Example specification of message exchanges},
                   label={lst:not-impl-exm},
                   keywordstyle=\color{blue}\bfseries,morekeywords={sends,If,then}]
A sends B either message x or y.

If A sends B message x,
    then C sends D message z.

If A sends B message y,
then C sends D message w.
\end{lstlisting}

While the specification can be expressed using several of the formalisms
mentioned earlier, some of them are capable of revealing 
that it is, in fact, \emph{impossible} to implement in a real distributed system.
The reason is that process $C$ cannot determine which message to send
to $D$ without knowing which message $A$ sent to $B$, because this 
information is not locally available to $C$.
\end{example}

The realisability problem in this work is examined from a theoretical
perspective to provide a more formal and precise understanding of the
fundamental limits that exist and why syntactical constraints of certain
models work.  

Unlike the standard approach to \textit{Global Types} in MPST, which often
relies on a purely syntactic representation, in this work we adopt a more
\textit{semantic approach}. Specifically, we represent global types as
\textit{automata}. This automata-based
representation is highly modular, incorporating various
\textit{network semantics} (such as asynchronous, peer-to-peer, causal
ordering, and synchronous semantics) as explicit parameters of the
framework. Such parameterization allows a flexible analysis of different
communication models within a unified setting.
In this framework, we interpret the semantics of a global type as a set of
Message Sequence Charts (MSCs). It is therefore useful to recall related
questions that have been studied in the context of 
MSCs~\cite{alur2000inference,alur2003inference}. 
These formalisms provide both historical context and technical insights, 
and several known results from this line of work will be directly leveraged 
in the present study.

Message Sequence Charts (MSCs) are a standardised graphical formalism,
introduced in 1992 \cite{MSCStandard}, used to describe trace languages 
for specifying communication behaviour. Thanks to their simplicity and 
intuitive semantics, MSCs have been widely adopted in industry.
Figure~\ref{fig:msc-cli-ser} illustrates a simple example based on a
minimal clientâ€“server architecture. To give more context, 
an extension of this formalism,
known as High-Level Message Sequence Charts (HMSCs), was later
introduced \cite{HMSCStandard}. HMSCs enable the definition of
MSCs as nodes connected by transitions and are used to model more
complex patterns of message flows by capturing sequences, alternatives,
or iterations of atomic MSC scenarios.

\begin{figure}[!ht]
\centering
\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
	\declinst{P1}{Client}{}
	\declinst{P2}{Server}{}

	\mess{request}{P1}{P2}
	\nextlevel
	\mess{answer}{P2}{P1}
\end{msc}
\caption{Simple example of a client-server architecture.}
\label{fig:msc-cli-ser}
\end{figure}

The \emph{weak realisability problem} for MSCs asks whether there 
exists a distributed implementation that can realise all behaviours of a 
finite set of MSCs without introducing additional ones. A stronger variant, 
called \emph{safe realisability}, requires the implementation to also be 
\textbf{deadlock-free}. 

\textbf{Remark.} The term ``realisability'' has several synonyms in the
literature. In other works, it is often referred to as 
\emph{implementability} or \emph{projectability}. Each of these terms, 
depending on the formal model considered, comes with slightly different 
definitions. Some of these variations will be analysed in 
Chapter~\ref{sec:rel}.

With MSCs, the work of Di Giusto et al.~\cite{di2023partial} introduces
interesting communication semantics and a hierarchy among them. The main
goal of their study was to establish a hierarchy that preserves
\emph{monotonic} properties: if a property holds for a given communication
semantics, it should also hold for all semantics contained within it.
However, they showed that this monotonicity only applies to certain
properties. In this work, we continue the study within the same framework,
focusing on the realisability property.  

In the following paragraphs, we describe some of these communication
semantics informally, using examples to highlight the differences between
them. In particular, we will later formally define \verb|synch| in
Definition~\ref{def:synchronous}, as this communication semantics is used
in the main contribution of this thesis. Chapter~\ref{sec:rel} continues
the discussion by presenting additional communication semantics and
summarizing the relevance of the work by Di Giusto et
al.~\cite{di2023partial}. Some examples of different communication semantics
are illustrated in Figures~\ref{fig:asy} and~\ref{fig:sync}, whose
\emph{membership} in these classes can be verified using an online MSC
tool~\cite{MSCTool}.

\paragraph{Fully asynchronous.}
In the fully asynchronous communication model (\verb|asy|), messages can be 
received at any time after they have been sent, and send events are 
non-blocking. This model can be viewed as an unordered ``bag'' in which 
all messages are stored and retrieved by processes when needed. It is also 
referred to as \emph{non-FIFO}. The formal definition coincides with that of 
an MSC (Definition~\ref{def:msc}). Figure~\ref{fig:asy} illustrates an example of asynchronous 
communication.

\begin{figure}[!ht]
    \centering
      \begin{msc}[draw frame=none, draw head=none, msc keyword=, 
                  head height=0px, label distance=0.5ex, 
                  foot height=0px, foot distance=0px]{}
          \declinst{p}{p}{}
          \declinst{q}{q}{}

          \mess[pos=0.2]{$m_1$}{p}{q}[2]
          \nextlevel
          \mess[pos=0.8]{$m_2$}{p}{q}
      \end{msc}
  \caption{Asynchronous semantic example.}
  \label{fig:asy}
\end{figure}

\paragraph{Peer-to-peer.} 
In the peer-to-peer (\verb|p2p|) communication model, any two messages sent from one 
process to another are always received in the same order as they are sent.
An alternative name is FIFO. An example is shown in Figure~\ref{fig:p2p}.

\begin{figure}[!ht]
    \centering
      \begin{msc}[draw frame=none, draw head=none, msc keyword=, 
                    head height=0px, label distance=0.5ex, 
                    foot height=0px, foot distance=0px]{}
            \declinst{p}{p}{}
            \declinst{q}{q}{}
            \declinst{r}{r}{}

            \mess[pos=0.15]{$m_1$}{p}{r}[3]
            \nextlevel
            \mess[pos=0.8]{$m_2$}{p}{q}
            \nextlevel
            \mess[pos=0.8]{$m_3$}{q}{r}
        \end{msc}
  \caption{Peer-to-peer semantic example.}
  \label{fig:p2p}
\end{figure}

\paragraph{Synchronous.}
The synchronous (\verb|synch|) communication model imposes 
the existence of a scheduling such that any send event is 
immediately followed by its corresponding receive event. 
An example for this communication model is shown in 
Figure~\ref{fig:sync}.c. A formal definition is given later 
for this semantic (Definition~\ref{def:synchronous}).

\begin{figure}[!ht]
    \centering
      \begin{msc}[draw frame=none, draw head=none, msc keyword=, 
                  head height=0px, label distance=0.5ex, 
                  foot height=0px, foot distance=0px]{}
          \declinst{p}{p}{}
          \declinst{q}{q}{}
          \declinst{r}{r}{}

          \mess{$m_1$}{p}{q}
          \nextlevel
          \mess{$m_2$}{q}{r}
      \end{msc}
  \caption{Synchronous semantic example.}
  \label{fig:sync}
\end{figure}

The definition of these models will become central in
the reduction techniques explored in this work: 
simplifying the study of realisability
by reducing richer semantics to the synchronous case.

\section{Reduction to synchronous semantic}\label{sec:red}
Theorem~\cite[Theorem 5.3]{di2025realisability} suggests that reasoning
about realisability could become more tractable under \emph{synchronous}
semantics for automata-based solutions. In
synchronous communication, send and receive actions are tightly coupled,
effectively eliminating the nondeterminism introduced by asynchronous
message buffering. The theorem is formally stated in Chapter~\ref{sec:rescu}.

Formally, the theorem shows that if a global type is realisable under
synchronous semantics, then, under certain conditions, it is also
realisable in more general models, such as peer-to-peer semantics. This
reduction requires constraints such as \emph{orphan-freedom} (no message 
sent is left unmatched) and \emph{deadlock-freedom}.  

We present the theorem here informally, using the standard meanings of
terms that have already been introduced:
a global type $G$ is deadlock-free realisable in \verb|p2p| if and only if
the following four conditions hold
\begin{itemize}
  \item the language generated by $G$'s local type has synchronous semantics;
  \item all $G$'s projections are orphan-free;
  \item all the traces of the MSCs' language of $G$ are deadlock-free
  in \verb|p2p|;
  \item $G$ is realisable in synchronous semantics.
\end{itemize}

The second and third conditions are already known to be decidable and 
can be automatically verified. The focus of this thesis is instead on 
the fourth condition, namely checking whether a global type is 
realisable in synchronous semantics. The undecidability result 
presented in Chapter~\ref{sec:proof} shows that this condition cannot 
be verified in general. Consequently, the theorem above must be refined 
by introducing further restrictions that ensure decidability.  

This observation motivates the second part of the thesis: 
Chapter~\ref{sec:rescu} presents the extension of the 
\textsc{ReSCu} tool, which provides practical verification of 
properties such as \emph{deadlock-freedom} and \emph{progress}. These 
results should be understood as building blocks toward identifying 
restricted subclasses of synchronous systems that admit decidable 
realisability checks, complementing the undecidability findings of 
the theoretical contribution.

Given the context, the developments presented in this thesis can be 
grouped into two main
contributions, one theoretical and one practical, both closely
connected.

\section{Contributions}
The main contributions of this work are: 
\begin{itemize}
    \item a proof of the \textbf{undecidability} of the 
    \textit{weak realisability} problem under the synchronous 
    semantics of our framework;
    \item an extension and improvement of the model-checking tool 
    \textsc{ReSCu}~\cite{rescurepo}, enabling the verification of 
    \textit{deadlock-freedom} and \textit{progress} for synchronous 
    systems.
\end{itemize}

These two contributions are closely connected: they both address the 
realisability problem, but from two complementary angles. The first 
contribution establishes undecidability, showing that in the general 
case the weak realisability problem cannot be solved for synchronous semantic. 
This motivates the second contribution: once undecidability is proven, 
there is a clear need to identify suitable restrictions of the problem 
that yield decidability results. The model-checking framework presented 
in the second part of the thesis could be a foundational step 
towards this direction, providing practical verification techniques that 
can serve as building blocks for further decidability analyses.

The thesis is structured as follows. 
Chapters~\ref{sec:pre} and~\ref{sec:proof} 
then introduce the formal definitions and present the main theoretical 
contribution. Chapter~\ref{sec:rescu} develops the practical 
contributions through the \textsc{ReSCu} tool. 
Chapter~\ref{sec:rel} presents 
a detailed overview of related work, comparing different approaches in 
the literature and highlighting how this thesis departs from them. Finally, 
Chapter~\ref{sec:end} concludes with a discussion of the results and 
outlines directions for future research and development.
