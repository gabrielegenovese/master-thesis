\documentclass{beamer}
% \usetheme{metropolis}

\usepackage{../macros}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{caption}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage{color}
\usepackage{listings}
\usepackage{pgfpages}
\usepackage{msc}
\usepackage[utf8]{inputenc}
\usepackage[british]{babel}
\usepackage{amsmath}
% \setbeameroption{show notes on second screen=right}

\usetikzlibrary{automata,arrows,positioning,shapes,snakes}
\usetikzlibrary{calc,matrix,decorations.pathmorphing}
\usetikzlibrary{shapes.geometric,arrows.meta}
\pgfmathtruncatemacro\distance{1}

\addtobeamertemplate{navigation symbols}{}{%
    \usebeamerfont{footline}%
    \usebeamercolor[fg]{footline}%
    \hspace{1em}%
    \insertframenumber/\inserttotalframenumber
}

\setbeamercolor{footline}{fg=blue}
\setbeamerfont{footline}{series=\bfseries}

\tikzset{
    mylabel/.style={
    font=\tiny,
    sloped,
    above
  }
}

\lstset{language=erlang, basicstyle=\sffamily\footnotesize,
  keywordstyle=\color{blue}, numberstyle=\tiny, numbers=none,
  showspaces=false, showstringspaces=false, frame=tL, mathescape=true,
  backgroundcolor=\color{black!5}, morekeywords={send, to, from} }


\title{Realisability of Global Types:\\Decidability and Verification}
% \author{
% 	\textbf{Presentata da: Gabriele Genovese},
% 	Relatore: Prof. Ivan Lanese,
% 	Corelatori: Prof. Cinzia Di Giusto e Chiar.mo Prof. Étienne Lozes,
% 	Controrelatore: Chiar.mo Prof. Luca Padovani
% 	}
\author[Gabriele Genovese]{Presentata da: \textbf{Gabriele Genovese}\\[4mm]{\small 
	Relatore: Prof. Ivan Lanese \\ 
	\hspace{2.4mm} Correlatori: Prof. Cinzia Di Giusto \\ \hspace{30.8mm} Chiar.mo Prof. Étienne Lozes \\
	\hspace{8.8mm} Controrelatore: Chiar.mo Prof. Luca Padovani}
}
\date{30 Ottobre 2025}

\titlegraphic{\includegraphics[width=2cm]{../img/i3s.png}\hspace*{4.75cm}~%
   \includegraphics[width=1.4cm]{../img/logo.png}
}


\begin{document}

\maketitle
\note{
	Good morning, everyone. I'm Gabriele Genovese.
}


\begin{frame}{Multiparty Session Types}
	\begin{itemize}
		\item Honda, K., Yoshida, N., and Carbone, M. (2008)
		\item Verification and design of \emph{communication protocols} 
		\item Avoid \emph{deadlocks}, ensure \emph{progress}, etc...
	\end{itemize}

	\begin{center}
	\begin{tikzpicture}[
		node distance=1cm,
		every node/.style={font=\sffamily},
		rect/.style={rectangle, draw=black, minimum width=0.9cm, minimum height=0.9cm},
		circ/.style={circle, draw=black, minimum size=0.9cm},
		arrow/.style={-{Stealth}, thick}, scale=0.1
	]

	% Nodes
	\node[rect] (G) {\textcolor{red}{$\mathcal{G}$}};
	\node[circ, below=of G] (TB) {\textcolor{blue}{$L_\text{B}$}};
	\node[circ, left=of TB] (TA) {\textcolor{blue}{$L_\text{A}$}};
	\node[circ, right=of TB] (TC) {\textcolor{blue}{$L_\text{C}$}};

	\node[rect, below=of TA] (PA) {\textcolor{brown}{$P_\text{A}$}};
	\node[rect, below=of TB] (PB) {\textcolor{brown}{$P_\text{B}$}};
	\node[rect, below=of TC] (PC) {\textcolor{brown}{$P_\text{C}$}};

	\node[rect,draw=none,right=of TC] (LC) {\textbf{\textcolor{blue}{2. Local type}}};
	\node[rect,draw=none,above=of LC] (LG) {\textbf{\textcolor{red}{1. Global type}}};
	\node[rect,draw=none,below=of LC] (LG) {\textbf{\textcolor{brown}{3. Processes}}};

	% Arrows
	\draw[arrow] (G) -- (TA) node[midway, left] {Projection};
	\draw[arrow] (G) -- (TB);
	\draw[arrow] (G) -- (TC);

	\draw[arrow] (PA) -- (TA) node[midway, left] {Type checking};
	\draw[arrow] (PB) -- (TB);
	\draw[arrow] (PC) -- (TC);
	\draw[arrow] (TC) -- (PC);
	\draw[arrow] (TB) -- (PB);
	\draw[arrow] (TA) -- (PA);

	\end{tikzpicture}
	\end{center}
\end{frame}


\tikzstyle{box} = [rectangle, rounded corners, draw=blue!60, fill=blue!10, thick,
text width=7.5em, text centered, minimum height=2em]


% \newcommand{\marrow}[3]{#1\xrightarrow{#3}#2}
% \newcommand{\gtlabel}[3]{\marrow{#1}{#2}{#3}}
\begin{frame}{Global Types}
	\begin{itemize}
		\item Description of a \textbf{global} behavior of a system.
		\item Defined as automata
	\end{itemize}

	\bigskip

	\begin{center}
		\begin{tikzpicture}[node distance=1.5cm, auto]
			\node[state, initial, initial text={}] (s0) {1};
			\node[state] (s1) [above right=of s0] {2};
			\node[state] (s2) [below right=of s0] {3};
			\node[state,accepting] (s3) [right=of s1] {4};
			\node[state,accepting] (s4) [right=of s2] {5};

			\draw[->] (s0) to node[above,sloped]{$\gtlabel{A}{B}{x}$}(s1);
			\draw[->] (s0) to node[above,sloped]{$\gtlabel{A}{B}{y}$}(s2);
			\draw[->] (s1) to node[above,sloped]{$\gtlabel{C}{D}{z}$}(s3);
			\draw[->] (s2) to node[above,sloped]{$\gtlabel{C}{D}{w}$}(s4);

		\end{tikzpicture}
	\end{center}
\end{frame}

\begin{frame}{Local type}
	\begin{itemize}
		\item Point of view of a participant
		\item Obtained via \textit{projection} operation
		\item Behavior can differ for different communication semantics (p2p, sync) 
	\end{itemize}

	\bigskip

	\textbf{Realisability} problem: Does the implementation of a system 
  \textbf{respects} the behavior described?

	\bigskip

	$L(G) = L(\text{proj}(G))$

	% \begin{center}
	% 	\begin{tikzpicture}[node distance=3cm, auto]
	% 		\node[state, initial, initial text={}] (s0) {$s_0$};
	% 		\node[state] (s1) [right=of s0] {$s_1$};
	% 		\node[state,accepting] (s2) [right=of s1] {$s_2$};

	% 		\draw[->] (s0) -- node[above,sloped]{$A!B:ping$} (s1);
	% 		\draw[->] (s1) -- node[above,sloped]{$A?B:pong$} (s2);
	% 	\end{tikzpicture}
	% \end{center}

	% \begin{center}
	% 	\begin{tikzpicture}[node distance=3cm, auto]
	% 		\node[state, initial, initial text={}] (s0) {$s_0$};
	% 		\node[state] (s1) [right=of s0] {$s_1$};
	% 		\node[state,accepting] (s2) [right=of s1] {$s_2$};

	% 		\draw[->] (s0) -- node[above,sloped]{$B?A:ping$} (s1);
	% 		\draw[->] (s1) -- node[above,sloped]{$B!A:pong$} (s2);
	% 	\end{tikzpicture}
	% \end{center}
\end{frame}

% \begin{frame}{Example}
% 	Message Queuing Telemetry Transport (MQTT) protocol with two clients.
% 	\begin{center}
% 		\begin{tikzpicture}[node distance=3cm, auto]
% 			\node[state, initial, initial text={}] (s0) {$s_0$};
% 			\node[state] (s1) [above right=of s0] {$s_1$};
% 			\node[state] (s2) [right=of s0] {$s_2$};

% 			\draw[->, bend left=40] (s0) to node[above,sloped]{$\gtlabel{C_1}{B}{pub(m)}$}(s1);
% 			\draw[->] (s1) to node[above,sloped] {$\gtlabel{B}{C_2}{pub(m)}$} (s0);

% 			\draw[->, bend left=20] (s0) to node[above,sloped]{$\gtlabel{C_2}{B}{pub(m)}$}(s2);
% 			\draw[->] (s2) -- node[below,sloped]{$\gtlabel{B}{C_1}{pub(m)}$} (s0);
% 		\end{tikzpicture}
% 	\end{center}
% \end{frame}


\begin{frame}{The example is not realisable}
	This example is {\color{red}\textbf{not}} realisable 
	because $C$ doesn't know what $A$ sent.
	\begin{center}
		\begin{tikzpicture}[node distance=1.5cm, auto]
			\node[state, initial, initial text={}] (s0) {1};
			\node[state] (s1) [above right=of s0] {2};
			\node[state] (s2) [below right=of s0] {3};
			\node[state,accepting] (s3) [right=of s1] {4};
			\node[state,accepting] (s4) [right=of s2] {5};

			\draw[->] (s0) to node[above,sloped]{$\gtlabel{A}{B}{x}$}(s1);
			\draw[->] (s0) to node[above,sloped]{$\gtlabel{A}{B}{y}$}(s2);
			\draw[->] (s1) to node[above,sloped]{$\gtlabel{C}{D}{z}$}(s3);
			\draw[->] (s2) to node[above,sloped]{$\gtlabel{C}{D}{w}$}(s4);

		\end{tikzpicture}
	\end{center}

	The trace $\gtlabel{A}{B}{x};\gtlabel{C}{D}{w}$ does not appear in $L(G)$.
\end{frame}

% \begin{frame}[fragile]{Message Sequence Charts (MSC)}
% 	Diagrams used to represent traces of a behavior of the system.

% 	\bigskip

% 	% \hspace{-2em}
% 	\begin{minipage}{\textwidth}%0.45\textwidth}
% 		\centering
% 		\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
% 			\declinst{P1}{P1}{}
% 			\declinst{P2}{P2}{}
% 			\declinst{P3}{P3}{}

% 			\asyncmscmess{$m_1$}{P1}{P2}
% 			\asyncmscmess{$m_2$}{P2}{P3}
% 		\end{msc}
% 	\end{minipage}
% 	% \hspace{0.1\textwidth}
% 	% \begin{minipage}{0.45\textwidth}
% 	% 	\centering
% 	% 	\begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
% 	% 		\declinst{P1}{P1}{}
% 	% 		\declinst{P2}{P2}{}

% 	% 		\mess{$m_1$}{P1}{P2}[1]
% 	% 		\mess{$m_2$}{P2}{P1}[3]
% 	% 	\end{msc}
% 	% \end{minipage}
% 	% descrive gli eventi send and receive
% 	\begin{center}
% 		Events: \verb|send m1, receive m1, send m2, receive m2|
% 	\end{center}
% \end{frame}

% \begin{frame}{Communication models}
% 	More interesting: async, p2p, mb (mailbox), rsc (sync).

% \end{frame}

\begin{frame}{Reduction to sync [1]}
	\vspace{1.5cm}
	A global type $G$ is deadlock-free realisable in \textbf{p2p} iff:
	\begin{enumerate}
		\item $L_{\text{p2p}}(proj(G))$ is sync;
		\item $proj(G)$ is orphan-free in p2p; % (no message is sent but not received)
		\item $L_{\text{p2p}}(proj(G))$ is deadlock-free
		\item $G$ is weak realisable in sync
		\item $G$ is deadlock-free in sync
	\end{enumerate}
	
	\vspace{1.5cm}

	\small{[1] Di Giusto, Cinzia, Etienne Lozes, and Pascal Urso. "Realisability and Complementability of Multiparty Session Types." (2025).}
\end{frame}

\begin{frame}{Reduction to sync [1]}
	\vspace{1.5cm}
	A global type $G$ is deadlock-free realisable in \textbf{p2p} iff:
	\begin{enumerate}
		\item $L_{\text{p2p}}(proj(G))$ is sync;
		\item $proj(G)$ is orphan-free in p2p; % (no message is sent but not received)
		\item $L_{\text{p2p}}(proj(G))$ is deadlock-free
		\item $G$ is weak realisable in sync \hspace{4mm} \scalebox{1.5}{{\color{red}$\longleftarrow$}}
		\item $G$ is deadlock-free in sync 
	\end{enumerate}
	
	\vspace{1.5cm}

	\small{[1] Di Giusto, Cinzia, Etienne Lozes, and Pascal Urso. "Realisability and Complementability of Multiparty Session Types." (2025).}
\end{frame}

\begin{frame}[fragile]{First contribution}

	\vspace{1em}

	\begin{itemize}
		\item Realisability for sync global types is
    \textbf{undecidable}. \\ Proof: by reduction to the PCP problem.
    \item PCP: given a set of tiles, find an ordering such that the
    strings formed by the top and bottom halves are equal.
    \item Proof adaptated from Alur et al.~[2]
	\end{itemize}

	\begin{center}
		\includegraphics[width=0.6\textwidth]{../img/pcp.jpg}
	\end{center}

	\small{[2] Alur, Rajeev, Kousha Etessami, and Mihalis Yannakakis. ``Realizability and verification of MSC graphs.'' Theoretical Computer Science 331.1 (2005): 97-114.}
\end{frame}

\begin{frame}{Reduction to sync [1]}
	\vspace{1.5cm}
	A global type $G$ is deadlock-free realisable in \textbf{p2p} iff:
	\begin{enumerate}
		\item $L_{\text{p2p}}(proj(G))$ is sync;
		\item $proj(G)$ is orphan-free in p2p; % (no message is sent but not received)
		\item $L_{\text{p2p}}(proj(G))$ is deadlock-free
		\item $G$ is weak realisable in sync
		\item $G$ is deadlock-free in sync \hspace{4mm} \scalebox{1.5}{{\color{red}$\longleftarrow$}}
	\end{enumerate}
	
	\vspace{1.5cm}

	\small{[1] Di Giusto, Cinzia, Etienne Lozes, and Pascal Urso. ``Realisability and Complementability of Multiparty Session Types.'' (2025).}
\end{frame}

\begin{frame}[fragile]{Second contribution}

	\begin{itemize}
		\item \textsc{ReSCu}: Model-checking TUI tool written in OCaml
		\bigskip
		\item Added two verification if \emph{sync} system:
		\begin{itemize}
			\item \emph{Deadlock}: a final state is always reachable
			\item \emph{Progress}: the system can always perform an action
		\end{itemize} 
	\end{itemize}
	
\end{frame}

\begin{frame}[fragile]{\textsc{ReSCu} Example - Dining Philosophers}
	Two Philosophers, two forks.

	\bigskip

	\begin{lstlisting}
This system is RSC.
There are some sink states:
Sink: Id=11 Configuration={F0:4; F1:3; P1:2; P2:2}
There are some deadlock states:
Deadlock: Id=4 Configuration={F0:2; F1:1; P1:1; P2:1}
Deadlock: Id=11 Configuration={F0:4; F1:3; P1:2; P2:2}
...
    \end{lstlisting}
\end{frame}


\begin{frame}{\textsc{ReSCu} Example - Dining Philosophers}
\begin{center}
\begin{tikzpicture}[node distance=2cm and .4cm, transform shape]
  \node[state,minimum size=0.4cm] (n_1) {1};
  \node[state,minimum size=0.4cm] (n_2) [below right of=n_1] {2};
  \node[state,minimum size=0.4cm] (n_3) [below left of=n_1] {3};
  \node[state,minimum size=0.4cm] (n_4) [below right of=n_2] {4};
  \node[state,minimum size=0.4cm] (n_5) [below left of=n_3] {5};
  \node[state,minimum size=0.4cm] (n_6) [below of=n_1, yshift=-0.8cm, fill=yellow] {6};
  \node[state,minimum size=0.4cm] (n_7) [below left of=n_6, fill=yellow] {7};
  \node[state,minimum size=0.4cm] (n_8) [below right of=n_6, fill=yellow] {8};
  \node[state,minimum size=0.4cm] (n_9) [below of=n_1, yshift=-3.8cm, fill=red] {9};
  \node[state,minimum size=0.4cm] (n_10) [below of=n_5] {...};
  \node[state,minimum size=0.4cm] (n_11) [below of=n_4] {...};
  
  \draw[->] (n_1) edge[bend left=5] node[mylabel] {P1→F1:req} (n_2);
  \draw[->] (n_1) edge[bend right=5]  node[mylabel] {P2→F0:req} (n_3);
  \draw[->] (n_2) -- node[mylabel] {P2→F0:req} (n_6);
  \draw[->] (n_3) -- node[mylabel] {P1→F1:req} (n_6);
  \draw[->] (n_2) -- node[mylabel] {P1→F1:ack} (n_4);
  \draw[->] (n_3) -- node[mylabel] {P2→F0:ack} (n_5);
  \draw[->] (n_4) -- node[mylabel] {...} (n_11);
  \draw[->] (n_5) -- node[mylabel] {...} (n_10);
  \draw[->] (n_6) -- node[mylabel] {P1→F1:ack} (n_7);
  \draw[->] (n_6) -- node[mylabel] {P2→F0:ack} (n_8);
  \draw[->] (n_7) -- node[mylabel] {P2→F0:ack} (n_9);
  \draw[->] (n_8) -- node[mylabel] {P1→F1:ack} (n_9);
\end{tikzpicture}
\end{center}
\end{frame}



% \begin{frame}{State of the art}
% 	The study about implementability can be summarized in:

% 	\bigskip

% 	\begin{center}
% 		% spendere più parole su standard:
% 		% la sintassi degli MPST permette l'implementazione
% 		\begin{tikzpicture}[node distance=0.64cm]
% 			\node (ind) [box] {Standard};
% 			\node (sci) [box, right=1cm of ind] {Semantic};
% 			\node (desc1) [box, below=of ind] {By contruction, easy and efficient\\E.g. MPST};
% 			\node (desc3) [box, below=of sci] {More foundamental: what renders a global type implementable?};
% 			\draw[->] (ind) -- (desc1);
% 			\draw[->] (sci) -- (desc3);
% 			\draw[->] (desc1) -- (ind);
% 			\draw[->] (desc3) -- (sci);
% 			\draw[->] (ind) -- (sci);
% 		\end{tikzpicture}
% 	\end{center}
% \end{frame}

% \begin{frame}[fragile]{Our approach: semantic}
% 	\begin{itemize}
% 		\item What render a specification implementable?
% 		\item What is the limit? Why syntactical constraints works?
% 		\item \textbf{Aim}: Extend existing results and generalize to
% 		      different communication models
% 		      % \begin{itemize}
% 		      %  \item \verb|p2p|
% 		      %  \item \verb|mailbox|
% 		      %  \item \verb|sync|
% 		      % \end{itemize}
% 	\end{itemize}
% \end{frame}


\begin{frame}[fragile]{Conclusion}

	Summary of contributions:
	\begin{itemize}
		\item Proof of undecidability for weak realisability in sync
		\item Enriched the tool \textsc{ReSCu} 
	\end{itemize}

	\bigskip

	Future work:
	\begin{itemize}
		\item Prove undecidability of deadlock-free realisability for sync global types
		\item Continue the development of \textsc{ReSCu}
	\end{itemize}

	\bigskip

	\begin{center}
		\Large Thanks! Questions?
	\end{center}
\end{frame}

\begin{frame}{Weak and Safe realisability}
  \begin{itemize}
    \item 
    Weak realisability: the global type $G$ is \emph{weak} realisable in sync if 
    there exist a CFSM system that can implement the global type.

    \bigskip

    \item 
    Weak realisability: the global type $G$ is \emph{safe} realisable in sync if 
    it is \emph{weak realisable} and the CFSM system is \textbf{deadlock free}.

  \end{itemize}
\end{frame}

\begin{frame}{The MSC $M_i^n$}
	\begin{center}
    \begin{msc}[draw frame=none, draw head=none, msc keyword=, head height=0px, label distance=0.5ex, foot height=0px, foot distance=0px]{}
			\declinst{P1}{P1}{}
			\declinst{P2}{P2}{}
			\declinst{P3}{P3}{}
			\declinst{P4}{P4}{}

			\syncmscmess{$(i,n)$}{P1}{P2}
			\syncmscmess{$i$}{P1}{P4}
			\syncmscmess{$(i,n)$}{P4}{P3}
			\syncmscmess{$x_i^1$}{P2}{P3}
			\syncmscmess{...}{P2}{P3}
			\syncmscmess{$x_i^c$}{P2}{P3}
		\end{msc}
  \end{center}
\end{frame}

\begin{frame}{The global type $G_i^n$}
\begin{center}
\begin{tikzpicture}[->, node distance=33mm, on grid, auto]
  \node[state] (q0) {$q_0$};
  \node[state] (q1) [right=of q0] {$q_1$};
  \node[state] (q2) [right=of q1] {$q_2$};
  \node[state] (q3) [below left=of q0] {$q_3$};
  \node[state] (q4) [right=of q3] {$q_4$};
  \node[state] (q5) [right=of q4] {$\cdots$};
  \node[state,accepting] (q6) [right=of q5] {$q_x$};

  \path (q0) edge[] node[above] {$P_1\to P_2:(i,n)$} (q1);
  \path (q1) edge[] node[above] {$P_1\to P_4:i$} (q2);
  \path (q2) edge[] node[above left] {$P_4\to P_3:(i,n)$} (q3.60);
  \path (q3) edge[] node[above] {$P_2\to P_3:x_i^1$} (q4);
  \path (q4) edge[] node[above] {$P_2\to P_3:...$} (q5);
  \path (q5) edge[] node[above] {$P_2\to P_3:x_i^c$} (q6);
\end{tikzpicture}
\end{center}
\end{frame}


\begin{frame}{The global type $L^*$}
  \vspace{-1cm}
  \begin{center}
  \begin{tikzpicture}[->, node distance=24mm,on grid,auto,scale=0.7]
		\node[state] (vI) {$v_I$};
		\node[state] (qI2) [right=of vI] {$\cdots$};
		\node[state] (qI1) [above=of qI2] {$q_0^{G^1}$};
		\node[state] (qI3) [below=of qI2] {$q_0^{G^n}$};
		\node[state] (qM1) [right=of qI1] {$\cdots$};
		\node[state] (qM2) [right=of qI2] {$\cdots$};
		\node[state] (qM3) [right=of qI3] {$\cdots$};
		\node[state] (qF1) [right=of qM1] {$q_f^{G^1}$};
		\node[state] (qF2) [right=of qM2] {$\cdots$};
		\node[state] (qF3) [right=of qM3] {$q_f^{G^n}$};
		\node[state,accepting] (vT) [right=of qF2] {$v_T$};

		\path (vI) edge[] node[above] {$\epsilon$} (qI1);
		\path (vI) edge[] node[above] {$\epsilon$} (qI2);
		\path (vI) edge[] node[above] {$\epsilon$} (qI3);
		\path (qI1) edge[] node[above] {...} (qM1);
		\path (qI2) edge[] node[above] {} (qM2);
		\path (qI3) edge[] node[above] {...} (qM3);
		\path (qM1) edge[] node[above] {...} (qF1);
		\path (qM2) edge[] node[above] {} (qF2);
		\path (qM3) edge[] node[above] {..} (qF3);
		\path (qF1) edge[] node[above] {$\epsilon$} (vT);
		\path (qF2) edge[] node[above] {$\epsilon$} (vT);
		\path (qF3) edge[] node[above] {$\epsilon$} (vT);
		
		\draw (qF1.135) to [bend right=30] node[above] {$\epsilon$} (qI1.45);
		\draw (qF2.135) to [bend right=30] node[above] {$\epsilon$} (qI2.45);
		\draw (qF3.135) to [bend right=30] node[above] {$\epsilon$} (qI3.45);

		\draw (qF1.225) to node[above] {$\epsilon$} (qI2.60);
		\draw (qF3.120) to node[above] {$\epsilon$} (qI2.315);
		
		\draw (qF3) .. controls +(8,10) and +(1,3) .. node[midway,above] {$\epsilon$} (qI1);
		\draw (qF1) ..  controls +(8,-10) and +(1,-3) .. node[midway,above] {$\epsilon$} (qI3);
	\end{tikzpicture}
  \end{center}
\end{frame}

\end{document}
